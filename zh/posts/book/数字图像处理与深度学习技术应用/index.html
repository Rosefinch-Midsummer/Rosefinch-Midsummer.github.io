<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>《数字图像处理与深度学习技术应用》 | 天漢帝國復興錄</title><meta name=keywords content="数字图像处理"><meta name=description content="概论
前言
这本书编得很不好，有不少错误之处（一看就是学生搞出来的烂书），但作为速通手册，还是可以阅读一下的。
OpenCV 模块——官网

简介
OpenCV 教程
OpenCV-Python 教程
OpenCV.js 教程
contrib 模块教程
常见问题解答
参考文献
主模块

core. 核心功能
imgproc. 图像处理
imgcodecs. 图像文件读写
videoio. 视频 I/O
highgui. 高级 GUI
video. 视频分析
calib3d. 相机标定与 3D 重建
features2d. 2D 特征框架
objdetect. 目标检测
dnn. 深度神经网络模块
ml. 机器学习
flann. 多维空间中的聚类与搜索
photo. 计算摄影
stitching. 图像拼接
gapi. 图 API


扩展模块

alphamat. Alpha 抠图
aruco. Aruco 标记，模块功能已移至 objdetect 模块
bgsegm. 改进的背景-前景分割方法
bioinspired. 受生物启发的视觉模型和衍生工具
cannops. Ascend 加速的计算机视觉
ccalib. 用于 3D 重建的自定义标定图案
cudaarithm. 矩阵运算Cudaarithm。矩阵运算
cudabgsegm. 背景分割
cudacodec. 视频编码/解码
cudafeatures2d. 特征检测与描述
cudafilters. 图像滤波
cudaimgproc. 图像处理
cudalegacy. 遗留支持
cudaobjdetect. 目标检测
cudaoptflow. 光流
cudastereo. 立体匹配
cudawarping. 图像形变
cudev. 设备层
cvv. 用于计算机视觉程序交互式视觉调试的 GUI
datasets. 处理不同数据集的框架
dnn_objdetect. 用于目标检测的 DNN
dnn_superres. 用于超分辨率的 DNN
dpm. 可变形部件模型
face. 人脸分析
fastcv. FastCV 硬件加速函数的模块封装
freetype. 使用 freetype/harfbuzz 绘制 UTF-8 字符串
fuzzy. 基于模糊数学的图像处理
hdf. 分层数据格式 I/O 例程
hfs. 用于高效图像分割的分层特征选择
img_hash. 该模块提供了不同图像哈希算法的实现。
intensity_transform. 该模块提供了用于调整图像对比度的强度变换算法的实现。
julia. OpenCV 的 Julia 绑定
line_descriptor. 从图像中提取的线的二进制描述符
mcc. Macbeth 色卡模块
optflow. 光流算法
ovis. OGRE 3D 可视化器
phase_unwrapping. 相位展开 API
plot. Mat 数据的绘图函数
quality. 图像质量分析 (IQA) API
rapid. 基于轮廓的 3D 对象跟踪
reg. 图像配准
rgbd. RGB-D 处理
saliency. 显著性 API
sfm. 运动恢复结构
shape. 形状距离与匹配
signal. 信号处理
stereo. 立体匹配算法
structured_light. 结构光 API
superres. 超分辨率
surface_matching. 表面匹配
text. 场景文本检测与识别
tracking. 跟踪 API
videostab. 视频稳定
viz. 3D 可视化器
wechat_qrcode. 微信 QR 码检测器，用于检测和解析 QR 码。
xfeatures2d. 额外的 2D 特征框架
ximgproc. 扩展图像处理
xobjdetect. 扩展目标检测
xphoto. 额外的照片处理算法



OpenCV（Open Source Computer Vision Library）是一个开源的计算机视觉和机器学习软件库。"><meta name=author content="RM"><link rel=canonical href=https://rosefinch-midsummer.github.io/zh/posts/book/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%8A%80%E6%9C%AF%E5%BA%94%E7%94%A8/><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><meta name=referrer content="no-referrer-when-downgrade"><link crossorigin=anonymous href=/assets/css/stylesheet.2211ca3164be7830024f6aad2b3a2e520843a64f8f048445c3401c1249aa051d.css integrity="sha256-IhHKMWS+eDACT2qtKzouUghDpk+PBIRFw0AcEkmqBR0=" rel="preload stylesheet" as=style><link rel=icon href=https://rosefinch-midsummer.github.io/img/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://rosefinch-midsummer.github.io/img/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://rosefinch-midsummer.github.io/img/favicon-32x32.png><link rel=apple-touch-icon href=https://rosefinch-midsummer.github.io/img/apple-touch-icon.png><link rel=mask-icon href=https://rosefinch-midsummer.github.io/img/android-chrome-192x192.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://rosefinch-midsummer.github.io/zh/posts/book/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%8A%80%E6%9C%AF%E5%BA%94%E7%94%A8/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><meta property="og:url" content="https://rosefinch-midsummer.github.io/zh/posts/book/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%8A%80%E6%9C%AF%E5%BA%94%E7%94%A8/"><meta property="og:site_name" content="天漢帝國復興錄"><meta property="og:title" content="《数字图像处理与深度学习技术应用》"><meta property="og:description" content="概论 前言 这本书编得很不好，有不少错误之处（一看就是学生搞出来的烂书），但作为速通手册，还是可以阅读一下的。
OpenCV 模块——官网
简介 OpenCV 教程 OpenCV-Python 教程 OpenCV.js 教程 contrib 模块教程 常见问题解答 参考文献 主模块 core. 核心功能 imgproc. 图像处理 imgcodecs. 图像文件读写 videoio. 视频 I/O highgui. 高级 GUI video. 视频分析 calib3d. 相机标定与 3D 重建 features2d. 2D 特征框架 objdetect. 目标检测 dnn. 深度神经网络模块 ml. 机器学习 flann. 多维空间中的聚类与搜索 photo. 计算摄影 stitching. 图像拼接 gapi. 图 API 扩展模块 alphamat. Alpha 抠图 aruco. Aruco 标记，模块功能已移至 objdetect 模块 bgsegm. 改进的背景-前景分割方法 bioinspired. 受生物启发的视觉模型和衍生工具 cannops. Ascend 加速的计算机视觉 ccalib. 用于 3D 重建的自定义标定图案 cudaarithm. 矩阵运算Cudaarithm。矩阵运算 cudabgsegm. 背景分割 cudacodec. 视频编码/解码 cudafeatures2d. 特征检测与描述 cudafilters. 图像滤波 cudaimgproc. 图像处理 cudalegacy. 遗留支持 cudaobjdetect. 目标检测 cudaoptflow. 光流 cudastereo. 立体匹配 cudawarping. 图像形变 cudev. 设备层 cvv. 用于计算机视觉程序交互式视觉调试的 GUI datasets. 处理不同数据集的框架 dnn_objdetect. 用于目标检测的 DNN dnn_superres. 用于超分辨率的 DNN dpm. 可变形部件模型 face. 人脸分析 fastcv. FastCV 硬件加速函数的模块封装 freetype. 使用 freetype/harfbuzz 绘制 UTF-8 字符串 fuzzy. 基于模糊数学的图像处理 hdf. 分层数据格式 I/O 例程 hfs. 用于高效图像分割的分层特征选择 img_hash. 该模块提供了不同图像哈希算法的实现。 intensity_transform. 该模块提供了用于调整图像对比度的强度变换算法的实现。 julia. OpenCV 的 Julia 绑定 line_descriptor. 从图像中提取的线的二进制描述符 mcc. Macbeth 色卡模块 optflow. 光流算法 ovis. OGRE 3D 可视化器 phase_unwrapping. 相位展开 API plot. Mat 数据的绘图函数 quality. 图像质量分析 (IQA) API rapid. 基于轮廓的 3D 对象跟踪 reg. 图像配准 rgbd. RGB-D 处理 saliency. 显著性 API sfm. 运动恢复结构 shape. 形状距离与匹配 signal. 信号处理 stereo. 立体匹配算法 structured_light. 结构光 API superres. 超分辨率 surface_matching. 表面匹配 text. 场景文本检测与识别 tracking. 跟踪 API videostab. 视频稳定 viz. 3D 可视化器 wechat_qrcode. 微信 QR 码检测器，用于检测和解析 QR 码。 xfeatures2d. 额外的 2D 特征框架 ximgproc. 扩展图像处理 xobjdetect. 扩展目标检测 xphoto. 额外的照片处理算法 OpenCV（Open Source Computer Vision Library）是一个开源的计算机视觉和机器学习软件库。"><meta property="og:locale" content="zh-cn#en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2026-01-11T12:34:25+08:00"><meta property="article:modified_time" content="2026-01-11T12:54:22+08:00"><meta property="article:tag" content="数字图像处理"><meta name=twitter:card content="summary"><meta name=twitter:title content="《数字图像处理与深度学习技术应用》"><meta name=twitter:description content="概论
前言
这本书编得很不好，有不少错误之处（一看就是学生搞出来的烂书），但作为速通手册，还是可以阅读一下的。
OpenCV 模块——官网

简介
OpenCV 教程
OpenCV-Python 教程
OpenCV.js 教程
contrib 模块教程
常见问题解答
参考文献
主模块

core. 核心功能
imgproc. 图像处理
imgcodecs. 图像文件读写
videoio. 视频 I/O
highgui. 高级 GUI
video. 视频分析
calib3d. 相机标定与 3D 重建
features2d. 2D 特征框架
objdetect. 目标检测
dnn. 深度神经网络模块
ml. 机器学习
flann. 多维空间中的聚类与搜索
photo. 计算摄影
stitching. 图像拼接
gapi. 图 API


扩展模块

alphamat. Alpha 抠图
aruco. Aruco 标记，模块功能已移至 objdetect 模块
bgsegm. 改进的背景-前景分割方法
bioinspired. 受生物启发的视觉模型和衍生工具
cannops. Ascend 加速的计算机视觉
ccalib. 用于 3D 重建的自定义标定图案
cudaarithm. 矩阵运算Cudaarithm。矩阵运算
cudabgsegm. 背景分割
cudacodec. 视频编码/解码
cudafeatures2d. 特征检测与描述
cudafilters. 图像滤波
cudaimgproc. 图像处理
cudalegacy. 遗留支持
cudaobjdetect. 目标检测
cudaoptflow. 光流
cudastereo. 立体匹配
cudawarping. 图像形变
cudev. 设备层
cvv. 用于计算机视觉程序交互式视觉调试的 GUI
datasets. 处理不同数据集的框架
dnn_objdetect. 用于目标检测的 DNN
dnn_superres. 用于超分辨率的 DNN
dpm. 可变形部件模型
face. 人脸分析
fastcv. FastCV 硬件加速函数的模块封装
freetype. 使用 freetype/harfbuzz 绘制 UTF-8 字符串
fuzzy. 基于模糊数学的图像处理
hdf. 分层数据格式 I/O 例程
hfs. 用于高效图像分割的分层特征选择
img_hash. 该模块提供了不同图像哈希算法的实现。
intensity_transform. 该模块提供了用于调整图像对比度的强度变换算法的实现。
julia. OpenCV 的 Julia 绑定
line_descriptor. 从图像中提取的线的二进制描述符
mcc. Macbeth 色卡模块
optflow. 光流算法
ovis. OGRE 3D 可视化器
phase_unwrapping. 相位展开 API
plot. Mat 数据的绘图函数
quality. 图像质量分析 (IQA) API
rapid. 基于轮廓的 3D 对象跟踪
reg. 图像配准
rgbd. RGB-D 处理
saliency. 显著性 API
sfm. 运动恢复结构
shape. 形状距离与匹配
signal. 信号处理
stereo. 立体匹配算法
structured_light. 结构光 API
superres. 超分辨率
surface_matching. 表面匹配
text. 场景文本检测与识别
tracking. 跟踪 API
videostab. 视频稳定
viz. 3D 可视化器
wechat_qrcode. 微信 QR 码检测器，用于检测和解析 QR 码。
xfeatures2d. 额外的 2D 特征框架
ximgproc. 扩展图像处理
xobjdetect. 扩展目标检测
xphoto. 额外的照片处理算法



OpenCV（Open Source Computer Vision Library）是一个开源的计算机视觉和机器学习软件库。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"📚文章","item":"https://rosefinch-midsummer.github.io/zh/posts/"},{"@type":"ListItem","position":2,"name":"📕閱讀","item":"https://rosefinch-midsummer.github.io/zh/posts/book/"},{"@type":"ListItem","position":3,"name":"《数字图像处理与深度学习技术应用》","item":"https://rosefinch-midsummer.github.io/zh/posts/book/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%8A%80%E6%9C%AF%E5%BA%94%E7%94%A8/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"《数字图像处理与深度学习技术应用》","name":"《数字图像处理与深度学习技术应用》","description":"概论 前言 这本书编得很不好，有不少错误之处（一看就是学生搞出来的烂书），但作为速通手册，还是可以阅读一下的。\nOpenCV 模块——官网\n简介 OpenCV 教程 OpenCV-Python 教程 OpenCV.js 教程 contrib 模块教程 常见问题解答 参考文献 主模块 core. 核心功能 imgproc. 图像处理 imgcodecs. 图像文件读写 videoio. 视频 I/O highgui. 高级 GUI video. 视频分析 calib3d. 相机标定与 3D 重建 features2d. 2D 特征框架 objdetect. 目标检测 dnn. 深度神经网络模块 ml. 机器学习 flann. 多维空间中的聚类与搜索 photo. 计算摄影 stitching. 图像拼接 gapi. 图 API 扩展模块 alphamat. Alpha 抠图 aruco. Aruco 标记，模块功能已移至 objdetect 模块 bgsegm. 改进的背景-前景分割方法 bioinspired. 受生物启发的视觉模型和衍生工具 cannops. Ascend 加速的计算机视觉 ccalib. 用于 3D 重建的自定义标定图案 cudaarithm. 矩阵运算Cudaarithm。矩阵运算 cudabgsegm. 背景分割 cudacodec. 视频编码/解码 cudafeatures2d. 特征检测与描述 cudafilters. 图像滤波 cudaimgproc. 图像处理 cudalegacy. 遗留支持 cudaobjdetect. 目标检测 cudaoptflow. 光流 cudastereo. 立体匹配 cudawarping. 图像形变 cudev. 设备层 cvv. 用于计算机视觉程序交互式视觉调试的 GUI datasets. 处理不同数据集的框架 dnn_objdetect. 用于目标检测的 DNN dnn_superres. 用于超分辨率的 DNN dpm. 可变形部件模型 face. 人脸分析 fastcv. FastCV 硬件加速函数的模块封装 freetype. 使用 freetype/harfbuzz 绘制 UTF-8 字符串 fuzzy. 基于模糊数学的图像处理 hdf. 分层数据格式 I/O 例程 hfs. 用于高效图像分割的分层特征选择 img_hash. 该模块提供了不同图像哈希算法的实现。 intensity_transform. 该模块提供了用于调整图像对比度的强度变换算法的实现。 julia. OpenCV 的 Julia 绑定 line_descriptor. 从图像中提取的线的二进制描述符 mcc. Macbeth 色卡模块 optflow. 光流算法 ovis. OGRE 3D 可视化器 phase_unwrapping. 相位展开 API plot. Mat 数据的绘图函数 quality. 图像质量分析 (IQA) API rapid. 基于轮廓的 3D 对象跟踪 reg. 图像配准 rgbd. RGB-D 处理 saliency. 显著性 API sfm. 运动恢复结构 shape. 形状距离与匹配 signal. 信号处理 stereo. 立体匹配算法 structured_light. 结构光 API superres. 超分辨率 surface_matching. 表面匹配 text. 场景文本检测与识别 tracking. 跟踪 API videostab. 视频稳定 viz. 3D 可视化器 wechat_qrcode. 微信 QR 码检测器，用于检测和解析 QR 码。 xfeatures2d. 额外的 2D 特征框架 ximgproc. 扩展图像处理 xobjdetect. 扩展目标检测 xphoto. 额外的照片处理算法 OpenCV（Open Source Computer Vision Library）是一个开源的计算机视觉和机器学习软件库。\n","keywords":["数字图像处理"],"articleBody":"概论 前言 这本书编得很不好，有不少错误之处（一看就是学生搞出来的烂书），但作为速通手册，还是可以阅读一下的。\nOpenCV 模块——官网\n简介 OpenCV 教程 OpenCV-Python 教程 OpenCV.js 教程 contrib 模块教程 常见问题解答 参考文献 主模块 core. 核心功能 imgproc. 图像处理 imgcodecs. 图像文件读写 videoio. 视频 I/O highgui. 高级 GUI video. 视频分析 calib3d. 相机标定与 3D 重建 features2d. 2D 特征框架 objdetect. 目标检测 dnn. 深度神经网络模块 ml. 机器学习 flann. 多维空间中的聚类与搜索 photo. 计算摄影 stitching. 图像拼接 gapi. 图 API 扩展模块 alphamat. Alpha 抠图 aruco. Aruco 标记，模块功能已移至 objdetect 模块 bgsegm. 改进的背景-前景分割方法 bioinspired. 受生物启发的视觉模型和衍生工具 cannops. Ascend 加速的计算机视觉 ccalib. 用于 3D 重建的自定义标定图案 cudaarithm. 矩阵运算Cudaarithm。矩阵运算 cudabgsegm. 背景分割 cudacodec. 视频编码/解码 cudafeatures2d. 特征检测与描述 cudafilters. 图像滤波 cudaimgproc. 图像处理 cudalegacy. 遗留支持 cudaobjdetect. 目标检测 cudaoptflow. 光流 cudastereo. 立体匹配 cudawarping. 图像形变 cudev. 设备层 cvv. 用于计算机视觉程序交互式视觉调试的 GUI datasets. 处理不同数据集的框架 dnn_objdetect. 用于目标检测的 DNN dnn_superres. 用于超分辨率的 DNN dpm. 可变形部件模型 face. 人脸分析 fastcv. FastCV 硬件加速函数的模块封装 freetype. 使用 freetype/harfbuzz 绘制 UTF-8 字符串 fuzzy. 基于模糊数学的图像处理 hdf. 分层数据格式 I/O 例程 hfs. 用于高效图像分割的分层特征选择 img_hash. 该模块提供了不同图像哈希算法的实现。 intensity_transform. 该模块提供了用于调整图像对比度的强度变换算法的实现。 julia. OpenCV 的 Julia 绑定 line_descriptor. 从图像中提取的线的二进制描述符 mcc. Macbeth 色卡模块 optflow. 光流算法 ovis. OGRE 3D 可视化器 phase_unwrapping. 相位展开 API plot. Mat 数据的绘图函数 quality. 图像质量分析 (IQA) API rapid. 基于轮廓的 3D 对象跟踪 reg. 图像配准 rgbd. RGB-D 处理 saliency. 显著性 API sfm. 运动恢复结构 shape. 形状距离与匹配 signal. 信号处理 stereo. 立体匹配算法 structured_light. 结构光 API superres. 超分辨率 surface_matching. 表面匹配 text. 场景文本检测与识别 tracking. 跟踪 API videostab. 视频稳定 viz. 3D 可视化器 wechat_qrcode. 微信 QR 码检测器，用于检测和解析 QR 码。 xfeatures2d. 额外的 2D 特征框架 ximgproc. 扩展图像处理 xobjdetect. 扩展目标检测 xphoto. 额外的照片处理算法 OpenCV（Open Source Computer Vision Library）是一个开源的计算机视觉和机器学习软件库。\nOpenCV 由一系列 C 函数和少量 C++ 类构成，同时提供了 Python、Java、MATLAB 等语言的接口。\nOpenCV 提供了大量的计算机视觉算法和图像处理工具，广泛应用于图像和视频的处理、分析以及机器学习领域。\nOpenCV 的设计目标是提供一套简单易用的计算机视觉基础库，帮助开发人员快速构建复杂的视觉应用。\nOpenCV 教程\n书籍简介 作者：杨淑莹\n其他责任人：杨淑莹\n出版日期：2024-08-01\n出版社：电子工业出版社\n页数：311\n内容简介 本书介绍了数字图像处理技术和深度学习技术，以及这些技术的应用，全书由12章组成。前九章主要介绍数字图像处理技术，内容包括：Python 环境搭建、位图基础、图像的显示、图像的几何变换、图像灰度变换、图像的平滑处理、图像锐化处理、图像分割及测量、图像的形态学处理，后三章主要介绍深度学习技术，将数字图像处理技术和深度学习技术相结合应用于项目开发，内容包括基于卷积神经网络CNN 模型的汉字识别、基于Faster RCNN 模型的手势识别、基于卷积神经网络CNN 模型的语音识别共三个项目的开发技术。本书仅仅介绍基本的理论知识，同时介绍将理论转化为代码的实现步骤和基于Python 开发工具的编程代码，并且可以将处理前与处理后的图像进行对照比较。实例程序的框架结构简单，代码简洁，使初学Python 者很快就掌握图像处理与图像识别技术。\n作者简介 略\n正文摘录 前 言 第1章 图像处理编程基础 1.1 Python开发基础 1.1.1 Python的安装 1.1.2 PyCharm的安装 1.1.3 OpenCV及常用库的配置 1.2 数字图像处理与深度学习技术简介 1.3 系统界面开发基础 1.4 图像显示 1.4.1 待处理图像的显示 1.4.2 处理后图像的显示 第2章 彩色图像特效处理 2.1 图像的颜色表示 2.1.1 像素的颜色 2.1.2 图像的存储结构 栅格存储\n位图格式文件扩展名为bmp\n分类：\n单色图像 8位灰度图像 8位伪彩色图像 24位真彩色图像 2.1.3 图像的精度 空间分辨率 空间分辨率指图像数字化的空间精细程度，是数字图像中划分图像的像素密度，即单位长度内的像素数，其单位是DPI（Dots Per Inch）。\n灰度级分辨率 灰度级分辨率表示每一像素的颜色值所占的二进制位数，也叫颜色深度。\n2.2 彩色图像的灰度化处理 灰度化处理是使RGB模型中R、G和B分量值相等。常用的转换方式为\n$$Gray(i, j) = 0.11 \\times R(i,j) + 0.59\\times G(i,j)+0.3\\times B(i,j)$$\n灰度化处理还有其他的方法，比如取三个分量的最大值、最小值、算术平均值等，目的都是使R、G和B分量值相等。\n灰度图像只能表示256种颜色，且灰度图像中只有灰度而没有色彩。\n2.3 彩色图像的着色处理 先灰度化处理，再修改对应的RGB通道值。\n2.4 彩色图像的亮度调整 亮度的调整是指人眼亮度感觉的调整，可以通过对RGB颜色增加或减少相同的增量来显示。\n2.5 彩色图像的对比度调整 增加对比度的意思就是把感兴趣的颜色范围拉开，使得该范围内的像素，其颜色亮的越亮，暗的越暗，从而达到了增强对比度的目的。对比度实际就是颜色分量值之间的差值。调整对比度实际就是对每一颜色分量值的最大值和最小值进行处理。\n增强因子\n阈值法\n2.6 彩色图像的曝光处理 图像曝光或多或少地损失了在原图像中可以看到的那些明快的颜色和色调。曝光处理的效果是基于照片技术的。曝光图像的算法原理是逆转数值小于128的RGB三分量。比如：\n$$g(i,j)=255-f(i,j), if f(i,j)\u003c128$$\n2.7 彩色图像的马赛克处理 马赛克效果原理是将图像从形式上划分为很多小块，在每块内的各个像素都取到相同的RGB分量值，从而对某些细节进行模糊化处理，使图像粗糙化。\n2.8 彩色图像的梯度锐化处理 锐化是为了突出图像的变化部分，使模糊的图像变得更加清晰。\n梯度锐化算法原理是将要处理的图像像素与它左对角线上的像素之间的差值乘以一个锐化度数，然后加上原先的像素值，即$new f(i,j) = \\frac{1}{4} \\times abs(f(i,j), f(i-1,j-1)) + f(i,j)$\n2.9 彩色图像的浮雕处理 浮雕效果就是只突出图像的变化部分，而相同颜色部分则被淡化，使图像出现纵深感，从而达到浮雕效果。\n浮雕效果针对灰度图像处理，就是只将图像的变化部分突出出来，而相同灰度部分则被淡化，使图像出现纵深感，从而达到浮雕效果。将要处理的像素取值为与处于前一个相邻像素间的差值，这样灰度平淡区因差值几乎为零则变成黑色，可以通过加上一个常量来增加一些亮度。\n常用方式：$G(i,j) = f(i,j) - f(i-1,j)+constant(128)$\n其中，G(i,j)为处理后图像的像素值，f(i,j)为原图像的像素值，f(i-1,j)为前一个相邻像素的值，常量通常取值为128。\n2.10 彩色图像的霓虹处理 霓虹效果用来描绘图像的轮廓，勾画颜色变化的边缘，产生轮廓发光的效果。先计算原图像当前像素f(i,j)的红、绿、蓝分量与其相同行f(i+1,j)及相同列f(i,j+1)相邻像素的梯度，即差的平方和的平方根，然后将梯度值作为处理后像素g(i,j)的红、绿、蓝的3个分量。\n上式中r1，g1，b1分别为原图像像素f(i,j)的红、绿、蓝分量值，r2,g2,b2分别为原图像同行相邻像素f(i+1,j)的红、绿、蓝分量值，r3,g3,b3分别为原图像同列相邻像素f(i,j+1)的红、绿、蓝分量值，Red，Green，Blue为图像处理后的像素f(i,j)的红、绿、蓝分量值。\n数字图像处理风格化效果——霓虹效果\n附录——挤压效果 挤压效果是将图像向内挤压，产生收缩变形。\n挤压效果的实现可以看成是数学极坐标的一种体现，将当前像素点、图像正中心点和过中心点的水平线这三要素画出一个极坐标，然后根据用户指定的挤压度，在当前点与中心点所连的直线上映射出一个像素点，最后将这个像素点作为目标点输出。\n第3章 图像的合成处理 图像的合成是指多幅图像之间进行的相互运算。多幅同样大小的图像可以进行代数运算和逻辑运算。\n3.1 图像的代数运算 图像相加的一个重要应用就是对同一场景的多幅图像求平均值，它可以有效地降低随机噪声的影响。\n图像相减可用于去除一幅图像中不需要的图案，也可以用于检测同一场景的两幅图像之间的变换，例如检测物体运动。\n图像相乘可以遮住图像中的某些部分，仅留下感兴趣的物体。\n图像相除可产生对颜色和多光谱图像分析十分重要的比率图像。\n3.1.1 图像加运算 3.1.2 图像减运算 3.2 图像的逻辑运算 以下是一些常见的按位逻辑运算的应用场景：\n图像融合，实现图像的混合、叠加、过渡和融合效果。 图像分割和掩膜（二进制图像）：可以通过位与运算提取图像中感兴趣的区域，或者通过位或运算将不同的图像部分进行组合。 图像修复和去除 图像处理和特征提取：可用于分析和检测图像之间的差异 图像二值化和阈值操作：分割图像、提取感兴趣的目标 3.2.1 位与运算 3.2.2 位或运算 3.2.3 位非运算 3.2.4 位异或运算 第4章 图像的几何变换 4.1 概述 简单讲，几何变换就是建立变化前后像素之间的映射关系。\n几何变换可以实现图像各像素点以坐标原点为中心的平移、缩放、镜像、旋转等各种变化。一般来说，变换后的点集=变化矩阵T✖变换前的点集矩阵。\n复合变换（级联变换）：基本变换按顺序进行\n常用的图形变换模型有如下三种形式：\n刚体变换：任意两像素点之间距离不变，仅局限在平移、旋转和反转（镜像） 仿射变换：直线保持平行关系，适用于平移、旋转、缩放和反转（镜像）等情况 投影变换：直线仍是直线，但基本不再保持平行关系 4.2 图像平移 4.3 图像镜像 4.4 图像缩放 4.5 图像转置 4.6 投影变换 4.7 图像旋转 小结 本章主要解决输入图像位置的标准化及大小的正规化，从而方便进行图像几何校正。\n图像的几何校正主要包括如下两步：\n（1）空间坐标变换。重新排列图像平面上的像素以恢复原有的空间关系。\n（2）灰度值的确定。对空间变换后的像素赋予相应的灰度值，使之恢复原位置的灰度值，称为灰度插值。\n第5章 图像的灰度变换 5.1 概述 灰度变化目的是改善画质，使图像的显示效果更加清晰。灰度变化可以增大图像的动态范围，扩展图像的对比度，使图像特征变得明显。灰度变化有时又被称为图像的对比度增强或对比度拉伸。\n图像对比度增强的方法可以分为两类：\n（1）直接对比度增强方法\n灰度变化函数\n（2）间接对比度增强方法\n直方图拉伸和直方图均衡化是两种最常见的间接对比度增强方法。\n5.2 二值化和阈值处理 5.3 灰度线性变换与分段线性变换 5.3.1 灰度线性变换 5.3.2 分段线性变换 5.4 灰度非线性变换 5.4.1 灰度对数变换 5.4.2 灰度指数变换 5.4.3 灰度幂次变换 5.5 灰度直方图 5.5.1 灰度直方图的概念 5.5.2 直方图正规化 5.5.3 直方图均衡化 5.5.4 自适应直方图均衡化 第6章 图像平滑处理 6.1 概述 图像平滑滤波的目的是消除噪声，保留有用信号，降低干扰，改善图像质量。同时，在提取较大目标前，去除太小的细节，或将目标内的小间断连接起来，平滑滤波也起到模糊作用。平滑滤波使图像的低频分量增强，同时削弱高频分量，用于消除图像中的随机噪声，起到平滑作用。\n对图像像素的处理方式可以划分为点处理和区域处理。\n图像平滑常用的方法是采用区域处理，利用相邻的像素值进行均值滤波或中值滤波。\n6.2 噪声消除法 6.2.1 二值图像的黑白点噪声滤波 6.2.2 消除孤立黑像素点 6.3 邻域平均法 邻域平均法是一种利用模板对图像进行模板操作（卷积运算）的方法。\n均值滤波器对高斯噪声的滤波效果较好，对椒盐噪声的滤波效果不好。原因:\n高斯噪声均值为0 椒盐噪声随机分布在不同的位置上，图像中有干净点也有污染点，噪声的均值不为0 邻域平均法通过一点和邻域内像素点求平均值来去除突变的像素点，优点是算法简单，计算速度快，代价是会造成图像一定程度上的模糊。\n6.3.1 3 ×3均值滤波 6.3.2 N×N均值滤波 6.3.3 超限邻域平均法 6.3.4 方框滤波 6.4 高斯滤波 高斯滤波中卷积核中的值按照距离中心点的远近分别赋予不同的权重值。\n6.5 中值滤波 邻域平均法属于低通滤波的处理方法。它在抑制噪声的同时使图像变得模糊，即图像的细节（例如边缘信息）被削弱，因而造成视觉上的失真。如果目的只是把干扰去除，而不是刻意让图像模糊，那么中值滤波能够抑制噪声又可以保持细节，是比较好的选择。\n6.5.1 N×N中值滤波 6.5.2 十字形中值滤波 6.5.3 N×N最大值滤波 6.6 双边滤波 双边滤波可以有效保护图像的边缘信息。\n6.7 2D卷积核的实现 自定义卷积核实现图像的平滑处理。可以使用cv2.filter2D()。\n6.8 加噪声处理 6.8.1 随机噪声 6.8.2 椒盐噪声 第7章 图像边缘锐化处理 在图像处理中，平滑处理（也称为模糊处理）是一种常见的操作，用于减少图像中的噪声或细节。\nOpenCV 提供了多种平滑处理的方法，本文将详细讲解四种常用的平滑处理技术：均值滤波、高斯滤波、中值滤波和双边滤波。\n7.1 概述 从本质上说，图像边缘是图像局部特性不连续性（灰度突变、颜色突变等）的反映，它标志着一个区域的终结和另一个区域的开始。边缘提取首先检出图像局部特性的不连续性，然后再将这些不连续的边缘像素连成完整的边界。边缘的特性是沿边缘走向的像素变化平缓，而垂直于边缘方向的像素变化剧烈。\n图像平滑往往使图像中的边界、轮廓变得模糊，而且单纯的微分运算会使低频成分损失很多，为了减少这类不利效果的影响，不丢失低频信息，提升边缘强度，这就需要利用图像边缘锐化技术，使边缘变得清晰。图像锐化处理也被称为高频提升滤波器。利用边缘检测方法求出边缘后，对边缘求梯度，将原图像和梯度图像叠加在一起，内容完整保留，而突出高频成分，同时，具有边缘锐化处理的效果。\n7.2 图像微分边缘检测 7.2.1 纵向微分边缘检测 7.2.2 横向微分边缘检测 7.2.3 双向一次微分边缘检测 7.3 常用的边缘检测算子及方法 7.3.1 Roberts边缘检测算子 7.3.2 Sobel边缘检测算子 7.3.3 Prewitt边缘检测算子 7.3.4 Scharr边缘检测算子 7.3.5 Krisch自适应边缘检测 7.3.6 Laplacian算子 7.3.7 LoG算子 7.3.8 Canny边缘检测 7.4 梯度锐化 7.4.1 提升边缘 7.4.2 根据梯度二值化图像 第8章 图像形态学处理 8.1 概述 目标和结构元素（刷子）是形态学的基本术语。\n形态学图像处理通常表现为一种邻域运算形式，在每个像素位置上邻域结构元素与二值图像对应的区域进行特定的逻辑运算，逻辑运算的结果为输出图像的相应元素。\n数学形态学最常见的基本运算有七种，分别为腐蚀、膨胀、开运算、闭运算、细化、黑帽和礼帽运算。用这些运算及其组合可以进行图像形状和结构的分析与处理，包括图像分割、特征抽取、边缘检测、图像滤波、图像增强和恢复等方面的工作。\n图像形态学操作是图像处理中的一种重要技术，主要用于处理二值图像（即黑白图像）。\nOpenCV 中的图像形态学操作是图像处理中的重要工具，通过腐蚀、膨胀、开运算、闭运算和形态学梯度等操作，可以实现对图像的噪声去除、对象分离、边缘检测等效果。掌握这些操作有助于更好地处理和分析图像数据。\n以下是 OpenCV 中常用的形态学操作及其函数：\n操作 函数 说明 应用场景 腐蚀 cv2.erode() 用结构元素扫描图像，如果结构元素覆盖的区域全是前景，则保留中心像素。 去除噪声、分离物体。 膨胀 cv2.dilate() 用结构元素扫描图像，如果结构元素覆盖的区域存在前景，则保留中心像素。 连接断裂的物体、填充空洞。 开运算 cv2.morphologyEx() 先腐蚀后膨胀。 去除小物体、平滑物体边界。 闭运算 cv2.morphologyEx() 先膨胀后腐蚀。 填充小孔洞、连接邻近物体。 形态学梯度 cv2.morphologyEx() 膨胀图减去腐蚀图。 提取物体边缘。 顶帽运算 cv2.morphologyEx() 原图减去开运算结果。 提取比背景亮的细小物体。 黑帽运算 cv2.morphologyEx() 闭运算结果减去原图。 提取比背景暗的细小物体。 8.2 图像腐蚀 作用：消除物体边界点，使边界向内收缩，可以去除小于结构元素的物体。\n8.2.1 水平腐蚀 8.2.2 垂直腐蚀 8.2.3 全方向腐蚀 8.3 图像膨胀 作用：对二值化物体的边界点进行扩充，将与物体边界点接触的所有背景点合并到该物体中，从而使边界向外部扩张。\n8.3.1 水平膨胀 8.3.2 垂直膨胀 8.3.3 全方向膨胀 8.4 图像开运算与闭运算 8.4.1 图像开运算 开运算：先腐蚀再膨胀\n腐蚀和膨胀不是一对互逆的操作。\n作用：去除孤立的小点等，平滑处理较大物体的边界，同时并不明显改变其面积\n8.4.2 图像闭运算 闭运算：先膨胀后腐蚀\n功能：填充物体内细小空洞，连接邻近物体，平滑其边界，同时并不明显改变其面积\n8.5 形态学梯度运算 形态学梯度运算是利用图像的碰撞图像减去腐蚀图像的一种形态学操作，这种操作可以获得图像的边缘信息。\n8.6 黑帽与礼帽运算 黑帽运算：原始图像减去闭运算的结果\n作用：获得比原始图像边缘更加黑暗的边缘部分，或者获得图像内部的小孔\n礼帽运算：原始图像减去开运算的结果\n作用：获得图像的噪声信息或者比原始图像边缘更亮的边缘部分\n8.7 图像细化 图像细化其实就是求图像骨架。图像骨架是二维二值目标的重要拓扑描述，指图像中央的骨骼部分，是描述图像几何及拓扑性质的重要特征之一。\n细化的目的就是在将图像的骨架提取出来并保持图像细小部分的连通性。对图像进行细化处理有助于突出形状特点和减少冗余信息。\n第9章 图像分割与测量 9.1 概述 图像分割与测量是图像识别工作的基础，分割的目的是将图像分为一些有意义的区域，如目标区域或前景区域，然后可以对这些区域进行描述，相当于提取出某些目标区域图像的特征。\n图像分割的基础是像素间的相似性和跳变性。\n图像分割依据工作对象可以分为点相关分割和区域相关分割。\n本章介绍图像分割的基本方法、轮廓提取方法、目标区域的标识、面积测量和周长测量。\n9.2 阈值法分割 9.2.1 直方图门限选择法 9.2.2 半阈值选择法 9.2.3 迭代阈值法 9.2.4 Otsu阈值法 9.2.5 自适应阈值法 9.2.6 分水岭算法 模拟水流通过地形起伏的现象\n9.3 投影法分割 9.3.1 水平投影分割 9.3.2 垂直投影分割 9.4 轮廓检测 9.4.1 邻域判断法 内部像素点可以删除\n9.4.2 边界跟踪法 9.4.3 区域生长法 将具有相似性质的像素集合起来构成区域\n9.4.4 轮廓检测与拟合 9.5 目标物体测量 9.5.1 区域标记 9.5.2 面积测量 9.5.3 周长测量 9.6 最小外包形状检测 9.6.1 最小外包矩形 9.6.2 最小外包圆形 9.6.3 最小外包三角形 9.6.4 最小外包椭圆形 9.7 霍夫检测 霍夫变换是一种特征提取(feature extraction)，被广泛应用在图像分析（image analysis）、计算机视觉(computer vision)以及数位影像处理(digital image processing)。霍夫变换是用来辨别找出物件中的特征，例如：线条。他的算法流程大致如下，给定一个物件、要辨别的形状的种类，算法会在参数空间(parameter space)中执行投票来决定物体的形状，而这是由累加空间(accumulator space)里的局部最大值(local maximum)来决定。\n现在广泛使用的霍夫变换是由Richard Duda和Peter Hart在1972年发明，并称之为广义霍夫变换(generalized Hough transform)，广义霍夫变换和更早前1962年的Paul Hough的专利有关。经典的霍夫变换是侦测图片中的直线，之后，霍夫变换不仅能识别直线，也能够识别任何形状，常见的有圆形、椭圆形。1981年，因为Dana H. Ballard的一篇期刊论文\"Generalizing the Hough transform to detect arbitrary shapes\"，让霍夫变换开始流行于计算机视觉界。\n9.7.1 霍夫直线检测 9.7.2 霍夫圆检测 第10章 图像频域变换处理 10.1 图像频域变换 图像频域变换是指图像从空域转换到频域的数学变换。常用的频域变换是傅里叶变换和离散余弦变换。\n频率的大小反映了信号变化的快慢。\n在图像处理中，图像的频率是表征图像中灰度变化剧烈程度的指标，是灰度在平面空间上的梯度，也就是图像灰度的变化速度。对图像而言，图像的边缘部分是突变部分，变化较快，因此反映在频域上是高频分量，图像的噪声在大部分情况下也是高频分量；图像平缓变化部分则为低频分量。高频分量解释信号的突变部分，而低频分量决定信号的“整体形象”。\n10.1.1 图像傅里叶变换 10.1.2 图像快速傅里叶变换 10.1.3 图像离散余弦变换 10.1.4 图像频域变换原理 傅里叶变换的物理意义是将图像的灰度分布函数变换为图像的频率分布函数。\n10.2 频域低通滤波 10.2.1 理想低通滤波 10.2.2 梯形低通滤波 10.2.3 巴特沃思低通滤波 10.2.4 指数低通滤波 10.3 频域高通滤波 10.3.1 理想高通滤波 10.3.2 梯形高通滤波 10.3.3 巴特沃思高通滤波 10.3.4 指数高通滤波 第11章 基于深度学习CNN模型的汉字识别 11.1 深度学习技术概述 11.2 CNN基本概念 滤波器是用于在卷积操作中提取特征的小矩阵（卷积核）。\n11.3 汉字识别系统设计 11.4 汉字图像预处理 预处理的步骤：\n获取需要获取的图像 进行灰度化、二值化处理 进行腐蚀、膨胀处理。腐蚀在数学形态学中的作用是消除噪声，是使边界向内部收缩的过程，可以把小于结构元素的物体去除。膨胀在数学形态中的作用与腐蚀的作用相反，它是对二值化边界点进行扩充，使边界向外部扩张的过程，使得断裂的笔画连接起来。 进行投影和分割。 保持分割后的图像。 11.5 投影与分割 11.6 构建汉字识别模型 11.6.1 构建CNN模型 11.6.2 识别模型训练 11.7 汉字识别模型检验 第12章 基于深度学习CNN模型的语音识别 语音识别模型训练采用的经典方法为提取语音信号的MFCC（梅尔倒谱系数）特征，使用HMM对MFCC特征进行训练。\n本模板采用的是语音信号的MFCC特征和CNN来进行模型训练。\n12.1 语音识别系统设计 12.2 语音信号预处理及特征提取 12.2.1 语音信号预处理 实现步骤：\n获取语音信号 语音信号预加重 语音信号分帧 语音信号加窗 语音信号快速傅里叶变换 12.2.2 MFCC特征提取 提取步骤：\n获取语音信号 语音信号预加重 语音信号分帧 语音信号加窗 语音信号快速傅里叶变换 语音信号的频谱数据通过三角带通滤波器 三角带通滤波器输出结果对数运算 对对数运算结果进行离散余弦变换，得到MFCC特征矩阵 根据MFCC特征矩阵值把特征矩阵转换为图像 12.3 构建语音识别模型 12.3.1 构建CNN模型 12.3.2 识别模型训练 12.4 语音识别模型检验 语音识别步骤：\n获取待识别语音 语音信号预处理及MFCC特征提取 将MFCC特征矩阵转换为图像 将语音信号输入已经训练好的卷积神经网络中 将识别结果（拼音）转为漢字结果 第13章 基于深度学习Faster R-CNN模型的手势识别 13.1 R-CNN目标检测与识别模型 13.2 边框回归原理 多元线性回归方程\n13.3 Faster R-CNN目标检测与识别模型 13.3.1 Faster R-CNN模型框架 13.3.2 基于区域提议网络的目标检测 13.3.3 基于RoI池化和分类技术的目标识别 13.4 手势识别系统设计 13.5 构建手势识别模型 13.5.1 构建Faster R-CNN模型 搭建提取主干特征的卷积神经网络 搭建检测目标的RPN网络 搭建RoI池化层 13.5.2 Faster R-CNN识别模型训练 主干特征提取 锚框贴标签 计算损失函数 RPN生成RoI 13.6 手势识别模型检验 ","wordCount":"8645","inLanguage":"zh","datePublished":"2026-01-11T12:34:25+08:00","dateModified":"2026-01-11T12:54:22+08:00","author":{"@type":"Person","name":"RM"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://rosefinch-midsummer.github.io/zh/posts/book/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%8A%80%E6%9C%AF%E5%BA%94%E7%94%A8/"},"publisher":{"@type":"Organization","name":"天漢帝國復興錄","logo":{"@type":"ImageObject","url":"https://rosefinch-midsummer.github.io/img/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://rosefinch-midsummer.github.io/zh/ accesskey=h title="天漢帝國復興錄 (Alt + H)">天漢帝國復興錄</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://rosefinch-midsummer.github.io/zh/ title=🏠主頁><span>🏠主頁</span></a></li><li><a href=https://rosefinch-midsummer.github.io/zh/posts title=📚文章><span>📚文章</span></a></li><li><a href=https://rosefinch-midsummer.github.io/zh/search title="🔍搜索 (Alt + /)" accesskey=/><span>🔍搜索</span></a></li><li><a href=https://rosefinch-midsummer.github.io/zh/archives title=⏱時間軸><span>⏱時間軸</span></a></li><li><a href=https://rosefinch-midsummer.github.io/zh/categories title=🧩分類><span>🧩分類</span></a></li><li><a href=https://rosefinch-midsummer.github.io/zh/tags title=🔖標簽><span>🔖標簽</span></a></li><li><a href=https://rosefinch-midsummer.github.io/zh/about title=🙋🏻‍♂️關于><span>🙋🏻‍♂️關于</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://rosefinch-midsummer.github.io/zh/>首頁</a>&nbsp;»&nbsp;<a href=https://rosefinch-midsummer.github.io/zh/posts/>📚文章</a>&nbsp;»&nbsp;<a href=https://rosefinch-midsummer.github.io/zh/posts/book/>📕閱讀</a></div><h1 class=post-title>《数字图像处理与深度学习技术应用》</h1><div class=post-meta>创建: 2026-01-11 |
更新: 2026-01-11 |
字数: 8645字 |
时长: 18分钟 |
RM</div><div class=meta-item>&nbsp·&nbsp
<span id=busuanzi_container_page_pv>本文阅读量<span id=busuanzi_value_page_pv></span>次</span></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目錄</span></summary><div class=inner><ul><li><a href=#%e6%a6%82%e8%ae%ba aria-label=概论>概论</a><ul><li><a href=#%e5%89%8d%e8%a8%80 aria-label=前言>前言</a></li><li><a href=#%e4%b9%a6%e7%b1%8d%e7%ae%80%e4%bb%8b aria-label=书籍简介>书籍简介</a></li><li><a href=#%e5%86%85%e5%ae%b9%e7%ae%80%e4%bb%8b aria-label=内容简介>内容简介</a></li><li><a href=#%e4%bd%9c%e8%80%85%e7%ae%80%e4%bb%8b aria-label=作者简介>作者简介</a></li></ul></li><li><a href=#%e6%ad%a3%e6%96%87%e6%91%98%e5%bd%95 aria-label=正文摘录>正文摘录</a><ul><li><a href=#%e5%89%8d-%e8%a8%80 aria-label="前 言">前 言</a></li><li><a href=#%e7%ac%ac1%e7%ab%a0-%e5%9b%be%e5%83%8f%e5%a4%84%e7%90%86%e7%bc%96%e7%a8%8b%e5%9f%ba%e7%a1%80 aria-label="第1章 图像处理编程基础">第1章 图像处理编程基础</a><ul><li><a href=#11-python%e5%bc%80%e5%8f%91%e5%9f%ba%e7%a1%80 aria-label="1.1 Python开发基础">1.1 Python开发基础</a><ul><li><a href=#111-python%e7%9a%84%e5%ae%89%e8%a3%85 aria-label="1.1.1 Python的安装">1.1.1 Python的安装</a></li><li><a href=#112-pycharm%e7%9a%84%e5%ae%89%e8%a3%85 aria-label="1.1.2 PyCharm的安装">1.1.2 PyCharm的安装</a></li><li><a href=#113-opencv%e5%8f%8a%e5%b8%b8%e7%94%a8%e5%ba%93%e7%9a%84%e9%85%8d%e7%bd%ae aria-label="1.1.3 OpenCV及常用库的配置">1.1.3 OpenCV及常用库的配置</a></li></ul></li><li><a href=#12-%e6%95%b0%e5%ad%97%e5%9b%be%e5%83%8f%e5%a4%84%e7%90%86%e4%b8%8e%e6%b7%b1%e5%ba%a6%e5%ad%a6%e4%b9%a0%e6%8a%80%e6%9c%af%e7%ae%80%e4%bb%8b aria-label="1.2 数字图像处理与深度学习技术简介">1.2 数字图像处理与深度学习技术简介</a></li><li><a href=#13-%e7%b3%bb%e7%bb%9f%e7%95%8c%e9%9d%a2%e5%bc%80%e5%8f%91%e5%9f%ba%e7%a1%80 aria-label="1.3 系统界面开发基础">1.3 系统界面开发基础</a></li><li><a href=#14-%e5%9b%be%e5%83%8f%e6%98%be%e7%a4%ba aria-label="1.4 图像显示">1.4 图像显示</a><ul><li><a href=#141-%e5%be%85%e5%a4%84%e7%90%86%e5%9b%be%e5%83%8f%e7%9a%84%e6%98%be%e7%a4%ba aria-label="1.4.1 待处理图像的显示">1.4.1 待处理图像的显示</a></li><li><a href=#142-%e5%a4%84%e7%90%86%e5%90%8e%e5%9b%be%e5%83%8f%e7%9a%84%e6%98%be%e7%a4%ba aria-label="1.4.2 处理后图像的显示">1.4.2 处理后图像的显示</a></li></ul></li></ul></li><li><a href=#%e7%ac%ac2%e7%ab%a0-%e5%bd%a9%e8%89%b2%e5%9b%be%e5%83%8f%e7%89%b9%e6%95%88%e5%a4%84%e7%90%86 aria-label="第2章 彩色图像特效处理">第2章 彩色图像特效处理</a><ul><li><a href=#21-%e5%9b%be%e5%83%8f%e7%9a%84%e9%a2%9c%e8%89%b2%e8%a1%a8%e7%a4%ba aria-label="2.1 图像的颜色表示">2.1 图像的颜色表示</a><ul><li><a href=#211-%e5%83%8f%e7%b4%a0%e7%9a%84%e9%a2%9c%e8%89%b2 aria-label="2.1.1 像素的颜色">2.1.1 像素的颜色</a></li><li><a href=#212-%e5%9b%be%e5%83%8f%e7%9a%84%e5%ad%98%e5%82%a8%e7%bb%93%e6%9e%84 aria-label="2.1.2 图像的存储结构">2.1.2 图像的存储结构</a></li><li><a href=#213-%e5%9b%be%e5%83%8f%e7%9a%84%e7%b2%be%e5%ba%a6 aria-label="2.1.3 图像的精度">2.1.3 图像的精度</a></li></ul></li><li><a href=#22-%e5%bd%a9%e8%89%b2%e5%9b%be%e5%83%8f%e7%9a%84%e7%81%b0%e5%ba%a6%e5%8c%96%e5%a4%84%e7%90%86 aria-label="2.2 彩色图像的灰度化处理">2.2 彩色图像的灰度化处理</a></li><li><a href=#23-%e5%bd%a9%e8%89%b2%e5%9b%be%e5%83%8f%e7%9a%84%e7%9d%80%e8%89%b2%e5%a4%84%e7%90%86 aria-label="2.3 彩色图像的着色处理">2.3 彩色图像的着色处理</a></li><li><a href=#24-%e5%bd%a9%e8%89%b2%e5%9b%be%e5%83%8f%e7%9a%84%e4%ba%ae%e5%ba%a6%e8%b0%83%e6%95%b4 aria-label="2.4 彩色图像的亮度调整">2.4 彩色图像的亮度调整</a></li><li><a href=#25-%e5%bd%a9%e8%89%b2%e5%9b%be%e5%83%8f%e7%9a%84%e5%af%b9%e6%af%94%e5%ba%a6%e8%b0%83%e6%95%b4 aria-label="2.5 彩色图像的对比度调整">2.5 彩色图像的对比度调整</a></li><li><a href=#26-%e5%bd%a9%e8%89%b2%e5%9b%be%e5%83%8f%e7%9a%84%e6%9b%9d%e5%85%89%e5%a4%84%e7%90%86 aria-label="2.6 彩色图像的曝光处理">2.6 彩色图像的曝光处理</a></li><li><a href=#27-%e5%bd%a9%e8%89%b2%e5%9b%be%e5%83%8f%e7%9a%84%e9%a9%ac%e8%b5%9b%e5%85%8b%e5%a4%84%e7%90%86 aria-label="2.7 彩色图像的马赛克处理">2.7 彩色图像的马赛克处理</a></li><li><a href=#28-%e5%bd%a9%e8%89%b2%e5%9b%be%e5%83%8f%e7%9a%84%e6%a2%af%e5%ba%a6%e9%94%90%e5%8c%96%e5%a4%84%e7%90%86 aria-label="2.8 彩色图像的梯度锐化处理">2.8 彩色图像的梯度锐化处理</a></li><li><a href=#29-%e5%bd%a9%e8%89%b2%e5%9b%be%e5%83%8f%e7%9a%84%e6%b5%ae%e9%9b%95%e5%a4%84%e7%90%86 aria-label="2.9 彩色图像的浮雕处理">2.9 彩色图像的浮雕处理</a></li><li><a href=#210-%e5%bd%a9%e8%89%b2%e5%9b%be%e5%83%8f%e7%9a%84%e9%9c%93%e8%99%b9%e5%a4%84%e7%90%86 aria-label="2.10 彩色图像的霓虹处理">2.10 彩色图像的霓虹处理</a></li><li><a href=#%e9%99%84%e5%bd%95%e6%8c%a4%e5%8e%8b%e6%95%88%e6%9e%9c aria-label=附录——挤压效果>附录——挤压效果</a></li></ul></li><li><a href=#%e7%ac%ac3%e7%ab%a0-%e5%9b%be%e5%83%8f%e7%9a%84%e5%90%88%e6%88%90%e5%a4%84%e7%90%86 aria-label="第3章 图像的合成处理">第3章 图像的合成处理</a><ul><li><a href=#31-%e5%9b%be%e5%83%8f%e7%9a%84%e4%bb%a3%e6%95%b0%e8%bf%90%e7%ae%97 aria-label="3.1 图像的代数运算">3.1 图像的代数运算</a><ul><li><a href=#311-%e5%9b%be%e5%83%8f%e5%8a%a0%e8%bf%90%e7%ae%97 aria-label="3.1.1 图像加运算">3.1.1 图像加运算</a></li><li><a href=#312-%e5%9b%be%e5%83%8f%e5%87%8f%e8%bf%90%e7%ae%97 aria-label="3.1.2 图像减运算">3.1.2 图像减运算</a></li></ul></li><li><a href=#32-%e5%9b%be%e5%83%8f%e7%9a%84%e9%80%bb%e8%be%91%e8%bf%90%e7%ae%97 aria-label="3.2 图像的逻辑运算">3.2 图像的逻辑运算</a><ul><li><a href=#321-%e4%bd%8d%e4%b8%8e%e8%bf%90%e7%ae%97 aria-label="3.2.1 位与运算">3.2.1 位与运算</a></li><li><a href=#322-%e4%bd%8d%e6%88%96%e8%bf%90%e7%ae%97 aria-label="3.2.2 位或运算">3.2.2 位或运算</a></li><li><a href=#323-%e4%bd%8d%e9%9d%9e%e8%bf%90%e7%ae%97 aria-label="3.2.3 位非运算">3.2.3 位非运算</a></li><li><a href=#324-%e4%bd%8d%e5%bc%82%e6%88%96%e8%bf%90%e7%ae%97 aria-label="3.2.4 位异或运算">3.2.4 位异或运算</a></li></ul></li></ul></li><li><a href=#%e7%ac%ac4%e7%ab%a0-%e5%9b%be%e5%83%8f%e7%9a%84%e5%87%a0%e4%bd%95%e5%8f%98%e6%8d%a2 aria-label="第4章 图像的几何变换">第4章 图像的几何变换</a><ul><li><a href=#41-%e6%a6%82%e8%bf%b0 aria-label="4.1 概述">4.1 概述</a></li><li><a href=#42-%e5%9b%be%e5%83%8f%e5%b9%b3%e7%a7%bb aria-label="4.2 图像平移">4.2 图像平移</a></li><li><a href=#43-%e5%9b%be%e5%83%8f%e9%95%9c%e5%83%8f aria-label="4.3 图像镜像">4.3 图像镜像</a></li><li><a href=#44-%e5%9b%be%e5%83%8f%e7%bc%a9%e6%94%be aria-label="4.4 图像缩放">4.4 图像缩放</a></li><li><a href=#45-%e5%9b%be%e5%83%8f%e8%bd%ac%e7%bd%ae aria-label="4.5 图像转置">4.5 图像转置</a></li><li><a href=#46-%e6%8a%95%e5%bd%b1%e5%8f%98%e6%8d%a2 aria-label="4.6 投影变换">4.6 投影变换</a></li><li><a href=#47-%e5%9b%be%e5%83%8f%e6%97%8b%e8%bd%ac aria-label="4.7 图像旋转">4.7 图像旋转</a></li><li><a href=#%e5%b0%8f%e7%bb%93 aria-label=小结>小结</a></li></ul></li><li><a href=#%e7%ac%ac5%e7%ab%a0-%e5%9b%be%e5%83%8f%e7%9a%84%e7%81%b0%e5%ba%a6%e5%8f%98%e6%8d%a2 aria-label="第5章 图像的灰度变换">第5章 图像的灰度变换</a><ul><li><a href=#51-%e6%a6%82%e8%bf%b0 aria-label="5.1 概述">5.1 概述</a></li><li><a href=#52-%e4%ba%8c%e5%80%bc%e5%8c%96%e5%92%8c%e9%98%88%e5%80%bc%e5%a4%84%e7%90%86 aria-label="5.2 二值化和阈值处理">5.2 二值化和阈值处理</a></li><li><a href=#53-%e7%81%b0%e5%ba%a6%e7%ba%bf%e6%80%a7%e5%8f%98%e6%8d%a2%e4%b8%8e%e5%88%86%e6%ae%b5%e7%ba%bf%e6%80%a7%e5%8f%98%e6%8d%a2 aria-label="5.3 灰度线性变换与分段线性变换">5.3 灰度线性变换与分段线性变换</a><ul><li><a href=#531-%e7%81%b0%e5%ba%a6%e7%ba%bf%e6%80%a7%e5%8f%98%e6%8d%a2 aria-label="5.3.1 灰度线性变换">5.3.1 灰度线性变换</a></li><li><a href=#532-%e5%88%86%e6%ae%b5%e7%ba%bf%e6%80%a7%e5%8f%98%e6%8d%a2 aria-label="5.3.2 分段线性变换">5.3.2 分段线性变换</a></li></ul></li><li><a href=#54-%e7%81%b0%e5%ba%a6%e9%9d%9e%e7%ba%bf%e6%80%a7%e5%8f%98%e6%8d%a2 aria-label="5.4 灰度非线性变换">5.4 灰度非线性变换</a><ul><li><a href=#541-%e7%81%b0%e5%ba%a6%e5%af%b9%e6%95%b0%e5%8f%98%e6%8d%a2 aria-label="5.4.1 灰度对数变换">5.4.1 灰度对数变换</a></li><li><a href=#542-%e7%81%b0%e5%ba%a6%e6%8c%87%e6%95%b0%e5%8f%98%e6%8d%a2 aria-label="5.4.2 灰度指数变换">5.4.2 灰度指数变换</a></li><li><a href=#543-%e7%81%b0%e5%ba%a6%e5%b9%82%e6%ac%a1%e5%8f%98%e6%8d%a2 aria-label="5.4.3 灰度幂次变换">5.4.3 灰度幂次变换</a></li></ul></li><li><a href=#55-%e7%81%b0%e5%ba%a6%e7%9b%b4%e6%96%b9%e5%9b%be aria-label="5.5 灰度直方图">5.5 灰度直方图</a><ul><li><a href=#551-%e7%81%b0%e5%ba%a6%e7%9b%b4%e6%96%b9%e5%9b%be%e7%9a%84%e6%a6%82%e5%bf%b5 aria-label="5.5.1 灰度直方图的概念">5.5.1 灰度直方图的概念</a></li><li><a href=#552-%e7%9b%b4%e6%96%b9%e5%9b%be%e6%ad%a3%e8%a7%84%e5%8c%96 aria-label="5.5.2 直方图正规化">5.5.2 直方图正规化</a></li><li><a href=#553-%e7%9b%b4%e6%96%b9%e5%9b%be%e5%9d%87%e8%a1%a1%e5%8c%96 aria-label="5.5.3 直方图均衡化">5.5.3 直方图均衡化</a></li><li><a href=#554-%e8%87%aa%e9%80%82%e5%ba%94%e7%9b%b4%e6%96%b9%e5%9b%be%e5%9d%87%e8%a1%a1%e5%8c%96 aria-label="5.5.4 自适应直方图均衡化">5.5.4 自适应直方图均衡化</a></li></ul></li></ul></li><li><a href=#%e7%ac%ac6%e7%ab%a0-%e5%9b%be%e5%83%8f%e5%b9%b3%e6%bb%91%e5%a4%84%e7%90%86 aria-label="第6章 图像平滑处理">第6章 图像平滑处理</a><ul><li><a href=#61-%e6%a6%82%e8%bf%b0 aria-label="6.1 概述">6.1 概述</a></li><li><a href=#62-%e5%99%aa%e5%a3%b0%e6%b6%88%e9%99%a4%e6%b3%95 aria-label="6.2 噪声消除法">6.2 噪声消除法</a><ul><li><a href=#621-%e4%ba%8c%e5%80%bc%e5%9b%be%e5%83%8f%e7%9a%84%e9%bb%91%e7%99%bd%e7%82%b9%e5%99%aa%e5%a3%b0%e6%bb%a4%e6%b3%a2 aria-label="6.2.1 二值图像的黑白点噪声滤波">6.2.1 二值图像的黑白点噪声滤波</a></li><li><a href=#622-%e6%b6%88%e9%99%a4%e5%ad%a4%e7%ab%8b%e9%bb%91%e5%83%8f%e7%b4%a0%e7%82%b9 aria-label="6.2.2 消除孤立黑像素点">6.2.2 消除孤立黑像素点</a></li></ul></li><li><a href=#63-%e9%82%bb%e5%9f%9f%e5%b9%b3%e5%9d%87%e6%b3%95 aria-label="6.3 邻域平均法">6.3 邻域平均法</a><ul><li><a href=#631-3-3%e5%9d%87%e5%80%bc%e6%bb%a4%e6%b3%a2 aria-label="6.3.1 3 ×3均值滤波">6.3.1 3 ×3均值滤波</a></li><li><a href=#632-nn%e5%9d%87%e5%80%bc%e6%bb%a4%e6%b3%a2 aria-label="6.3.2 N×N均值滤波">6.3.2 N×N均值滤波</a></li><li><a href=#633-%e8%b6%85%e9%99%90%e9%82%bb%e5%9f%9f%e5%b9%b3%e5%9d%87%e6%b3%95 aria-label="6.3.3 超限邻域平均法">6.3.3 超限邻域平均法</a></li><li><a href=#634-%e6%96%b9%e6%a1%86%e6%bb%a4%e6%b3%a2 aria-label="6.3.4 方框滤波">6.3.4 方框滤波</a></li></ul></li><li><a href=#64-%e9%ab%98%e6%96%af%e6%bb%a4%e6%b3%a2 aria-label="6.4 高斯滤波">6.4 高斯滤波</a></li><li><a href=#65-%e4%b8%ad%e5%80%bc%e6%bb%a4%e6%b3%a2 aria-label="6.5 中值滤波">6.5 中值滤波</a><ul><li><a href=#651-nn%e4%b8%ad%e5%80%bc%e6%bb%a4%e6%b3%a2 aria-label="6.5.1 N×N中值滤波">6.5.1 N×N中值滤波</a></li><li><a href=#652-%e5%8d%81%e5%ad%97%e5%bd%a2%e4%b8%ad%e5%80%bc%e6%bb%a4%e6%b3%a2 aria-label="6.5.2 十字形中值滤波">6.5.2 十字形中值滤波</a></li><li><a href=#653-nn%e6%9c%80%e5%a4%a7%e5%80%bc%e6%bb%a4%e6%b3%a2 aria-label="6.5.3 N×N最大值滤波">6.5.3 N×N最大值滤波</a></li></ul></li><li><a href=#66-%e5%8f%8c%e8%be%b9%e6%bb%a4%e6%b3%a2 aria-label="6.6 双边滤波">6.6 双边滤波</a></li><li><a href=#67--2d%e5%8d%b7%e7%a7%af%e6%a0%b8%e7%9a%84%e5%ae%9e%e7%8e%b0 aria-label="6.7  2D卷积核的实现">6.7 2D卷积核的实现</a></li><li><a href=#68-%e5%8a%a0%e5%99%aa%e5%a3%b0%e5%a4%84%e7%90%86 aria-label="6.8 加噪声处理">6.8 加噪声处理</a><ul><li><a href=#681-%e9%9a%8f%e6%9c%ba%e5%99%aa%e5%a3%b0 aria-label="6.8.1 随机噪声">6.8.1 随机噪声</a></li><li><a href=#682-%e6%a4%92%e7%9b%90%e5%99%aa%e5%a3%b0 aria-label="6.8.2 椒盐噪声">6.8.2 椒盐噪声</a></li></ul></li></ul></li><li><a href=#%e7%ac%ac7%e7%ab%a0-%e5%9b%be%e5%83%8f%e8%be%b9%e7%bc%98%e9%94%90%e5%8c%96%e5%a4%84%e7%90%86 aria-label="第7章 图像边缘锐化处理">第7章 图像边缘锐化处理</a><ul><li><a href=#71-%e6%a6%82%e8%bf%b0 aria-label="7.1 概述">7.1 概述</a></li><li><a href=#72-%e5%9b%be%e5%83%8f%e5%be%ae%e5%88%86%e8%be%b9%e7%bc%98%e6%a3%80%e6%b5%8b aria-label="7.2 图像微分边缘检测">7.2 图像微分边缘检测</a><ul><li><a href=#721-%e7%ba%b5%e5%90%91%e5%be%ae%e5%88%86%e8%be%b9%e7%bc%98%e6%a3%80%e6%b5%8b aria-label="7.2.1 纵向微分边缘检测">7.2.1 纵向微分边缘检测</a></li><li><a href=#722-%e6%a8%aa%e5%90%91%e5%be%ae%e5%88%86%e8%be%b9%e7%bc%98%e6%a3%80%e6%b5%8b aria-label="7.2.2 横向微分边缘检测">7.2.2 横向微分边缘检测</a></li><li><a href=#723-%e5%8f%8c%e5%90%91%e4%b8%80%e6%ac%a1%e5%be%ae%e5%88%86%e8%be%b9%e7%bc%98%e6%a3%80%e6%b5%8b aria-label="7.2.3 双向一次微分边缘检测">7.2.3 双向一次微分边缘检测</a></li></ul></li><li><a href=#73-%e5%b8%b8%e7%94%a8%e7%9a%84%e8%be%b9%e7%bc%98%e6%a3%80%e6%b5%8b%e7%ae%97%e5%ad%90%e5%8f%8a%e6%96%b9%e6%b3%95 aria-label="7.3 常用的边缘检测算子及方法">7.3 常用的边缘检测算子及方法</a><ul><li><a href=#731-roberts%e8%be%b9%e7%bc%98%e6%a3%80%e6%b5%8b%e7%ae%97%e5%ad%90 aria-label="7.3.1 Roberts边缘检测算子">7.3.1 Roberts边缘检测算子</a></li><li><a href=#732-sobel%e8%be%b9%e7%bc%98%e6%a3%80%e6%b5%8b%e7%ae%97%e5%ad%90 aria-label="7.3.2 Sobel边缘检测算子">7.3.2 Sobel边缘检测算子</a></li><li><a href=#733-prewitt%e8%be%b9%e7%bc%98%e6%a3%80%e6%b5%8b%e7%ae%97%e5%ad%90 aria-label="7.3.3 Prewitt边缘检测算子">7.3.3 Prewitt边缘检测算子</a></li><li><a href=#734-scharr%e8%be%b9%e7%bc%98%e6%a3%80%e6%b5%8b%e7%ae%97%e5%ad%90 aria-label="7.3.4 Scharr边缘检测算子">7.3.4 Scharr边缘检测算子</a></li><li><a href=#735-krisch%e8%87%aa%e9%80%82%e5%ba%94%e8%be%b9%e7%bc%98%e6%a3%80%e6%b5%8b aria-label="7.3.5 Krisch自适应边缘检测">7.3.5 Krisch自适应边缘检测</a></li><li><a href=#736-laplacian%e7%ae%97%e5%ad%90 aria-label="7.3.6 Laplacian算子">7.3.6 Laplacian算子</a></li><li><a href=#737-log%e7%ae%97%e5%ad%90 aria-label="7.3.7 LoG算子">7.3.7 LoG算子</a></li><li><a href=#738-canny%e8%be%b9%e7%bc%98%e6%a3%80%e6%b5%8b aria-label="7.3.8 Canny边缘检测">7.3.8 Canny边缘检测</a></li></ul></li><li><a href=#74-%e6%a2%af%e5%ba%a6%e9%94%90%e5%8c%96 aria-label="7.4 梯度锐化">7.4 梯度锐化</a><ul><li><a href=#741-%e6%8f%90%e5%8d%87%e8%be%b9%e7%bc%98 aria-label="7.4.1 提升边缘">7.4.1 提升边缘</a></li><li><a href=#742-%e6%a0%b9%e6%8d%ae%e6%a2%af%e5%ba%a6%e4%ba%8c%e5%80%bc%e5%8c%96%e5%9b%be%e5%83%8f aria-label="7.4.2 根据梯度二值化图像">7.4.2 根据梯度二值化图像</a></li></ul></li></ul></li><li><a href=#%e7%ac%ac8%e7%ab%a0-%e5%9b%be%e5%83%8f%e5%bd%a2%e6%80%81%e5%ad%a6%e5%a4%84%e7%90%86 aria-label="第8章 图像形态学处理">第8章 图像形态学处理</a><ul><li><a href=#81-%e6%a6%82%e8%bf%b0 aria-label="8.1 概述">8.1 概述</a></li><li><a href=#82-%e5%9b%be%e5%83%8f%e8%85%90%e8%9a%80 aria-label="8.2 图像腐蚀">8.2 图像腐蚀</a><ul><li><a href=#821-%e6%b0%b4%e5%b9%b3%e8%85%90%e8%9a%80 aria-label="8.2.1 水平腐蚀">8.2.1 水平腐蚀</a></li><li><a href=#822-%e5%9e%82%e7%9b%b4%e8%85%90%e8%9a%80 aria-label="8.2.2 垂直腐蚀">8.2.2 垂直腐蚀</a></li><li><a href=#823-%e5%85%a8%e6%96%b9%e5%90%91%e8%85%90%e8%9a%80 aria-label="8.2.3 全方向腐蚀">8.2.3 全方向腐蚀</a></li></ul></li><li><a href=#83-%e5%9b%be%e5%83%8f%e8%86%a8%e8%83%80 aria-label="8.3 图像膨胀">8.3 图像膨胀</a><ul><li><a href=#831-%e6%b0%b4%e5%b9%b3%e8%86%a8%e8%83%80 aria-label="8.3.1 水平膨胀">8.3.1 水平膨胀</a></li><li><a href=#832-%e5%9e%82%e7%9b%b4%e8%86%a8%e8%83%80 aria-label="8.3.2 垂直膨胀">8.3.2 垂直膨胀</a></li><li><a href=#833-%e5%85%a8%e6%96%b9%e5%90%91%e8%86%a8%e8%83%80 aria-label="8.3.3 全方向膨胀">8.3.3 全方向膨胀</a></li></ul></li><li><a href=#84-%e5%9b%be%e5%83%8f%e5%bc%80%e8%bf%90%e7%ae%97%e4%b8%8e%e9%97%ad%e8%bf%90%e7%ae%97 aria-label="8.4 图像开运算与闭运算">8.4 图像开运算与闭运算</a><ul><li><a href=#841-%e5%9b%be%e5%83%8f%e5%bc%80%e8%bf%90%e7%ae%97 aria-label="8.4.1 图像开运算">8.4.1 图像开运算</a></li><li><a href=#842-%e5%9b%be%e5%83%8f%e9%97%ad%e8%bf%90%e7%ae%97 aria-label="8.4.2 图像闭运算">8.4.2 图像闭运算</a></li></ul></li><li><a href=#85-%e5%bd%a2%e6%80%81%e5%ad%a6%e6%a2%af%e5%ba%a6%e8%bf%90%e7%ae%97 aria-label="8.5 形态学梯度运算">8.5 形态学梯度运算</a></li><li><a href=#86-%e9%bb%91%e5%b8%bd%e4%b8%8e%e7%a4%bc%e5%b8%bd%e8%bf%90%e7%ae%97 aria-label="8.6 黑帽与礼帽运算">8.6 黑帽与礼帽运算</a></li><li><a href=#87-%e5%9b%be%e5%83%8f%e7%bb%86%e5%8c%96 aria-label="8.7 图像细化">8.7 图像细化</a></li></ul></li><li><a href=#%e7%ac%ac9%e7%ab%a0-%e5%9b%be%e5%83%8f%e5%88%86%e5%89%b2%e4%b8%8e%e6%b5%8b%e9%87%8f aria-label="第9章 图像分割与测量">第9章 图像分割与测量</a><ul><li><a href=#91-%e6%a6%82%e8%bf%b0 aria-label="9.1 概述">9.1 概述</a></li><li><a href=#92-%e9%98%88%e5%80%bc%e6%b3%95%e5%88%86%e5%89%b2 aria-label="9.2 阈值法分割">9.2 阈值法分割</a><ul><li><a href=#921-%e7%9b%b4%e6%96%b9%e5%9b%be%e9%97%a8%e9%99%90%e9%80%89%e6%8b%a9%e6%b3%95 aria-label="9.2.1 直方图门限选择法">9.2.1 直方图门限选择法</a></li><li><a href=#922-%e5%8d%8a%e9%98%88%e5%80%bc%e9%80%89%e6%8b%a9%e6%b3%95 aria-label="9.2.2 半阈值选择法">9.2.2 半阈值选择法</a></li><li><a href=#923-%e8%bf%ad%e4%bb%a3%e9%98%88%e5%80%bc%e6%b3%95 aria-label="9.2.3 迭代阈值法">9.2.3 迭代阈值法</a></li><li><a href=#924-otsu%e9%98%88%e5%80%bc%e6%b3%95 aria-label="9.2.4 Otsu阈值法">9.2.4 Otsu阈值法</a></li><li><a href=#925-%e8%87%aa%e9%80%82%e5%ba%94%e9%98%88%e5%80%bc%e6%b3%95 aria-label="9.2.5 自适应阈值法">9.2.5 自适应阈值法</a></li><li><a href=#926-%e5%88%86%e6%b0%b4%e5%b2%ad%e7%ae%97%e6%b3%95 aria-label="9.2.6 分水岭算法">9.2.6 分水岭算法</a></li></ul></li><li><a href=#93-%e6%8a%95%e5%bd%b1%e6%b3%95%e5%88%86%e5%89%b2 aria-label="9.3 投影法分割">9.3 投影法分割</a><ul><li><a href=#931-%e6%b0%b4%e5%b9%b3%e6%8a%95%e5%bd%b1%e5%88%86%e5%89%b2 aria-label="9.3.1 水平投影分割">9.3.1 水平投影分割</a></li><li><a href=#932-%e5%9e%82%e7%9b%b4%e6%8a%95%e5%bd%b1%e5%88%86%e5%89%b2 aria-label="9.3.2 垂直投影分割">9.3.2 垂直投影分割</a></li></ul></li><li><a href=#94-%e8%bd%ae%e5%bb%93%e6%a3%80%e6%b5%8b aria-label="9.4 轮廓检测">9.4 轮廓检测</a><ul><li><a href=#941-%e9%82%bb%e5%9f%9f%e5%88%a4%e6%96%ad%e6%b3%95 aria-label="9.4.1 邻域判断法">9.4.1 邻域判断法</a></li><li><a href=#942-%e8%be%b9%e7%95%8c%e8%b7%9f%e8%b8%aa%e6%b3%95 aria-label="9.4.2 边界跟踪法">9.4.2 边界跟踪法</a></li><li><a href=#943-%e5%8c%ba%e5%9f%9f%e7%94%9f%e9%95%bf%e6%b3%95 aria-label="9.4.3 区域生长法">9.4.3 区域生长法</a></li><li><a href=#944-%e8%bd%ae%e5%bb%93%e6%a3%80%e6%b5%8b%e4%b8%8e%e6%8b%9f%e5%90%88 aria-label="9.4.4 轮廓检测与拟合">9.4.4 轮廓检测与拟合</a></li></ul></li><li><a href=#95-%e7%9b%ae%e6%a0%87%e7%89%a9%e4%bd%93%e6%b5%8b%e9%87%8f aria-label="9.5 目标物体测量">9.5 目标物体测量</a><ul><li><a href=#951-%e5%8c%ba%e5%9f%9f%e6%a0%87%e8%ae%b0 aria-label="9.5.1 区域标记">9.5.1 区域标记</a></li><li><a href=#952-%e9%9d%a2%e7%a7%af%e6%b5%8b%e9%87%8f aria-label="9.5.2 面积测量">9.5.2 面积测量</a></li><li><a href=#953-%e5%91%a8%e9%95%bf%e6%b5%8b%e9%87%8f aria-label="9.5.3 周长测量">9.5.3 周长测量</a></li></ul></li><li><a href=#96-%e6%9c%80%e5%b0%8f%e5%a4%96%e5%8c%85%e5%bd%a2%e7%8a%b6%e6%a3%80%e6%b5%8b aria-label="9.6 最小外包形状检测">9.6 最小外包形状检测</a><ul><li><a href=#961-%e6%9c%80%e5%b0%8f%e5%a4%96%e5%8c%85%e7%9f%a9%e5%bd%a2 aria-label="9.6.1 最小外包矩形">9.6.1 最小外包矩形</a></li><li><a href=#962-%e6%9c%80%e5%b0%8f%e5%a4%96%e5%8c%85%e5%9c%86%e5%bd%a2 aria-label="9.6.2 最小外包圆形">9.6.2 最小外包圆形</a></li><li><a href=#963-%e6%9c%80%e5%b0%8f%e5%a4%96%e5%8c%85%e4%b8%89%e8%a7%92%e5%bd%a2 aria-label="9.6.3 最小外包三角形">9.6.3 最小外包三角形</a></li><li><a href=#964-%e6%9c%80%e5%b0%8f%e5%a4%96%e5%8c%85%e6%a4%ad%e5%9c%86%e5%bd%a2 aria-label="9.6.4 最小外包椭圆形">9.6.4 最小外包椭圆形</a></li></ul></li><li><a href=#97-%e9%9c%8d%e5%a4%ab%e6%a3%80%e6%b5%8b aria-label="9.7 霍夫检测">9.7 霍夫检测</a><ul><li><a href=#971-%e9%9c%8d%e5%a4%ab%e7%9b%b4%e7%ba%bf%e6%a3%80%e6%b5%8b aria-label="9.7.1 霍夫直线检测">9.7.1 霍夫直线检测</a></li><li><a href=#972-%e9%9c%8d%e5%a4%ab%e5%9c%86%e6%a3%80%e6%b5%8b aria-label="9.7.2 霍夫圆检测">9.7.2 霍夫圆检测</a></li></ul></li></ul></li><li><a href=#%e7%ac%ac10%e7%ab%a0-%e5%9b%be%e5%83%8f%e9%a2%91%e5%9f%9f%e5%8f%98%e6%8d%a2%e5%a4%84%e7%90%86 aria-label="第10章 图像频域变换处理">第10章 图像频域变换处理</a><ul><li><a href=#101-%e5%9b%be%e5%83%8f%e9%a2%91%e5%9f%9f%e5%8f%98%e6%8d%a2 aria-label="10.1 图像频域变换">10.1 图像频域变换</a><ul><li><a href=#1011-%e5%9b%be%e5%83%8f%e5%82%85%e9%87%8c%e5%8f%b6%e5%8f%98%e6%8d%a2 aria-label="10.1.1 图像傅里叶变换">10.1.1 图像傅里叶变换</a></li><li><a href=#1012-%e5%9b%be%e5%83%8f%e5%bf%ab%e9%80%9f%e5%82%85%e9%87%8c%e5%8f%b6%e5%8f%98%e6%8d%a2 aria-label="10.1.2 图像快速傅里叶变换">10.1.2 图像快速傅里叶变换</a></li><li><a href=#1013-%e5%9b%be%e5%83%8f%e7%a6%bb%e6%95%a3%e4%bd%99%e5%bc%a6%e5%8f%98%e6%8d%a2 aria-label="10.1.3 图像离散余弦变换">10.1.3 图像离散余弦变换</a></li><li><a href=#1014-%e5%9b%be%e5%83%8f%e9%a2%91%e5%9f%9f%e5%8f%98%e6%8d%a2%e5%8e%9f%e7%90%86 aria-label="10.1.4 图像频域变换原理">10.1.4 图像频域变换原理</a></li></ul></li><li><a href=#102-%e9%a2%91%e5%9f%9f%e4%bd%8e%e9%80%9a%e6%bb%a4%e6%b3%a2 aria-label="10.2 频域低通滤波">10.2 频域低通滤波</a><ul><li><a href=#1021-%e7%90%86%e6%83%b3%e4%bd%8e%e9%80%9a%e6%bb%a4%e6%b3%a2 aria-label="10.2.1 理想低通滤波">10.2.1 理想低通滤波</a></li><li><a href=#1022-%e6%a2%af%e5%bd%a2%e4%bd%8e%e9%80%9a%e6%bb%a4%e6%b3%a2 aria-label="10.2.2 梯形低通滤波">10.2.2 梯形低通滤波</a></li><li><a href=#1023-%e5%b7%b4%e7%89%b9%e6%b2%83%e6%80%9d%e4%bd%8e%e9%80%9a%e6%bb%a4%e6%b3%a2 aria-label="10.2.3 巴特沃思低通滤波">10.2.3 巴特沃思低通滤波</a></li><li><a href=#1024-%e6%8c%87%e6%95%b0%e4%bd%8e%e9%80%9a%e6%bb%a4%e6%b3%a2 aria-label="10.2.4 指数低通滤波">10.2.4 指数低通滤波</a></li></ul></li><li><a href=#103-%e9%a2%91%e5%9f%9f%e9%ab%98%e9%80%9a%e6%bb%a4%e6%b3%a2 aria-label="10.3 频域高通滤波">10.3 频域高通滤波</a><ul><li><a href=#1031-%e7%90%86%e6%83%b3%e9%ab%98%e9%80%9a%e6%bb%a4%e6%b3%a2 aria-label="10.3.1 理想高通滤波">10.3.1 理想高通滤波</a></li><li><a href=#1032-%e6%a2%af%e5%bd%a2%e9%ab%98%e9%80%9a%e6%bb%a4%e6%b3%a2 aria-label="10.3.2 梯形高通滤波">10.3.2 梯形高通滤波</a></li><li><a href=#1033-%e5%b7%b4%e7%89%b9%e6%b2%83%e6%80%9d%e9%ab%98%e9%80%9a%e6%bb%a4%e6%b3%a2 aria-label="10.3.3 巴特沃思高通滤波">10.3.3 巴特沃思高通滤波</a></li><li><a href=#1034-%e6%8c%87%e6%95%b0%e9%ab%98%e9%80%9a%e6%bb%a4%e6%b3%a2 aria-label="10.3.4 指数高通滤波">10.3.4 指数高通滤波</a></li></ul></li></ul></li><li><a href=#%e7%ac%ac11%e7%ab%a0-%e5%9f%ba%e4%ba%8e%e6%b7%b1%e5%ba%a6%e5%ad%a6%e4%b9%a0cnn%e6%a8%a1%e5%9e%8b%e7%9a%84%e6%b1%89%e5%ad%97%e8%af%86%e5%88%ab aria-label="第11章 基于深度学习CNN模型的汉字识别">第11章 基于深度学习CNN模型的汉字识别</a><ul><li><a href=#111-%e6%b7%b1%e5%ba%a6%e5%ad%a6%e4%b9%a0%e6%8a%80%e6%9c%af%e6%a6%82%e8%bf%b0 aria-label="11.1 深度学习技术概述">11.1 深度学习技术概述</a></li><li><a href=#112-cnn%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5 aria-label="11.2 CNN基本概念">11.2 CNN基本概念</a></li><li><a href=#113-%e6%b1%89%e5%ad%97%e8%af%86%e5%88%ab%e7%b3%bb%e7%bb%9f%e8%ae%be%e8%ae%a1 aria-label="11.3 汉字识别系统设计">11.3 汉字识别系统设计</a></li><li><a href=#114-%e6%b1%89%e5%ad%97%e5%9b%be%e5%83%8f%e9%a2%84%e5%a4%84%e7%90%86 aria-label="11.4 汉字图像预处理">11.4 汉字图像预处理</a></li><li><a href=#115-%e6%8a%95%e5%bd%b1%e4%b8%8e%e5%88%86%e5%89%b2 aria-label="11.5 投影与分割">11.5 投影与分割</a></li><li><a href=#116-%e6%9e%84%e5%bb%ba%e6%b1%89%e5%ad%97%e8%af%86%e5%88%ab%e6%a8%a1%e5%9e%8b aria-label="11.6 构建汉字识别模型">11.6 构建汉字识别模型</a><ul><li><a href=#1161-%e6%9e%84%e5%bb%bacnn%e6%a8%a1%e5%9e%8b aria-label="11.6.1 构建CNN模型">11.6.1 构建CNN模型</a></li><li><a href=#1162-%e8%af%86%e5%88%ab%e6%a8%a1%e5%9e%8b%e8%ae%ad%e7%bb%83 aria-label="11.6.2 识别模型训练">11.6.2 识别模型训练</a></li></ul></li><li><a href=#117-%e6%b1%89%e5%ad%97%e8%af%86%e5%88%ab%e6%a8%a1%e5%9e%8b%e6%a3%80%e9%aa%8c aria-label="11.7 汉字识别模型检验">11.7 汉字识别模型检验</a></li></ul></li><li><a href=#%e7%ac%ac12%e7%ab%a0-%e5%9f%ba%e4%ba%8e%e6%b7%b1%e5%ba%a6%e5%ad%a6%e4%b9%a0cnn%e6%a8%a1%e5%9e%8b%e7%9a%84%e8%af%ad%e9%9f%b3%e8%af%86%e5%88%ab aria-label="第12章 基于深度学习CNN模型的语音识别">第12章 基于深度学习CNN模型的语音识别</a><ul><li><a href=#121-%e8%af%ad%e9%9f%b3%e8%af%86%e5%88%ab%e7%b3%bb%e7%bb%9f%e8%ae%be%e8%ae%a1 aria-label="12.1 语音识别系统设计">12.1 语音识别系统设计</a></li><li><a href=#122-%e8%af%ad%e9%9f%b3%e4%bf%a1%e5%8f%b7%e9%a2%84%e5%a4%84%e7%90%86%e5%8f%8a%e7%89%b9%e5%be%81%e6%8f%90%e5%8f%96 aria-label="12.2 语音信号预处理及特征提取">12.2 语音信号预处理及特征提取</a><ul><li><a href=#1221-%e8%af%ad%e9%9f%b3%e4%bf%a1%e5%8f%b7%e9%a2%84%e5%a4%84%e7%90%86 aria-label="12.2.1 语音信号预处理">12.2.1 语音信号预处理</a></li><li><a href=#1222-mfcc%e7%89%b9%e5%be%81%e6%8f%90%e5%8f%96 aria-label="12.2.2 MFCC特征提取">12.2.2 MFCC特征提取</a></li></ul></li><li><a href=#123-%e6%9e%84%e5%bb%ba%e8%af%ad%e9%9f%b3%e8%af%86%e5%88%ab%e6%a8%a1%e5%9e%8b aria-label="12.3 构建语音识别模型">12.3 构建语音识别模型</a><ul><li><a href=#1231-%e6%9e%84%e5%bb%bacnn%e6%a8%a1%e5%9e%8b aria-label="12.3.1 构建CNN模型">12.3.1 构建CNN模型</a></li><li><a href=#1232-%e8%af%86%e5%88%ab%e6%a8%a1%e5%9e%8b%e8%ae%ad%e7%bb%83 aria-label="12.3.2 识别模型训练">12.3.2 识别模型训练</a></li></ul></li><li><a href=#124-%e8%af%ad%e9%9f%b3%e8%af%86%e5%88%ab%e6%a8%a1%e5%9e%8b%e6%a3%80%e9%aa%8c aria-label="12.4 语音识别模型检验">12.4 语音识别模型检验</a></li></ul></li><li><a href=#%e7%ac%ac13%e7%ab%a0-%e5%9f%ba%e4%ba%8e%e6%b7%b1%e5%ba%a6%e5%ad%a6%e4%b9%a0faster-r-cnn%e6%a8%a1%e5%9e%8b%e7%9a%84%e6%89%8b%e5%8a%bf%e8%af%86%e5%88%ab aria-label="第13章 基于深度学习Faster R-CNN模型的手势识别">第13章 基于深度学习Faster R-CNN模型的手势识别</a><ul><li><a href=#131-r-cnn%e7%9b%ae%e6%a0%87%e6%a3%80%e6%b5%8b%e4%b8%8e%e8%af%86%e5%88%ab%e6%a8%a1%e5%9e%8b aria-label="13.1 R-CNN目标检测与识别模型">13.1 R-CNN目标检测与识别模型</a></li><li><a href=#132-%e8%be%b9%e6%a1%86%e5%9b%9e%e5%bd%92%e5%8e%9f%e7%90%86 aria-label="13.2 边框回归原理">13.2 边框回归原理</a></li><li><a href=#133-faster-r-cnn%e7%9b%ae%e6%a0%87%e6%a3%80%e6%b5%8b%e4%b8%8e%e8%af%86%e5%88%ab%e6%a8%a1%e5%9e%8b aria-label="13.3 Faster R-CNN目标检测与识别模型">13.3 Faster R-CNN目标检测与识别模型</a><ul><li><a href=#1331-faster-r-cnn%e6%a8%a1%e5%9e%8b%e6%a1%86%e6%9e%b6 aria-label="13.3.1 Faster R-CNN模型框架">13.3.1 Faster R-CNN模型框架</a></li><li><a href=#1332-%e5%9f%ba%e4%ba%8e%e5%8c%ba%e5%9f%9f%e6%8f%90%e8%ae%ae%e7%bd%91%e7%bb%9c%e7%9a%84%e7%9b%ae%e6%a0%87%e6%a3%80%e6%b5%8b aria-label="13.3.2 基于区域提议网络的目标检测">13.3.2 基于区域提议网络的目标检测</a></li><li><a href=#1333-%e5%9f%ba%e4%ba%8eroi%e6%b1%a0%e5%8c%96%e5%92%8c%e5%88%86%e7%b1%bb%e6%8a%80%e6%9c%af%e7%9a%84%e7%9b%ae%e6%a0%87%e8%af%86%e5%88%ab aria-label="13.3.3 基于RoI池化和分类技术的目标识别">13.3.3 基于RoI池化和分类技术的目标识别</a></li></ul></li><li><a href=#134-%e6%89%8b%e5%8a%bf%e8%af%86%e5%88%ab%e7%b3%bb%e7%bb%9f%e8%ae%be%e8%ae%a1 aria-label="13.4 手势识别系统设计">13.4 手势识别系统设计</a></li><li><a href=#135-%e6%9e%84%e5%bb%ba%e6%89%8b%e5%8a%bf%e8%af%86%e5%88%ab%e6%a8%a1%e5%9e%8b aria-label="13.5 构建手势识别模型">13.5 构建手势识别模型</a><ul><li><a href=#1351-%e6%9e%84%e5%bb%bafaster-r-cnn%e6%a8%a1%e5%9e%8b aria-label="13.5.1 构建Faster R-CNN模型">13.5.1 构建Faster R-CNN模型</a></li><li><a href=#1352-faster-r-cnn%e8%af%86%e5%88%ab%e6%a8%a1%e5%9e%8b%e8%ae%ad%e7%bb%83 aria-label="13.5.2 Faster R-CNN识别模型训练">13.5.2 Faster R-CNN识别模型训练</a></li></ul></li><li><a href=#136-%e6%89%8b%e5%8a%bf%e8%af%86%e5%88%ab%e6%a8%a1%e5%9e%8b%e6%a3%80%e9%aa%8c aria-label="13.6 手势识别模型检验">13.6 手势识别模型检验</a></li></ul></li></ul></li></ul></div></details></div><div class=post-content><h1 id=概论>概论<a hidden class=anchor aria-hidden=true href=#概论>#</a></h1><h2 id=前言>前言<a hidden class=anchor aria-hidden=true href=#前言>#</a></h2><p>这本书编得很不好，有不少错误之处（一看就是学生搞出来的烂书），但作为速通手册，还是可以阅读一下的。</p><p><a href=https://docs.opencv.ac.cn/4.13.0/index.html>OpenCV 模块——官网</a></p><ul><li><a href=https://docs.opencv.ac.cn/4.13.0/d1/dfb/intro.html>简介</a></li><li><a href=https://docs.opencv.ac.cn/4.13.0/d9/df8/tutorial_root.html>OpenCV 教程</a></li><li><a href=https://docs.opencv.ac.cn/4.13.0/d6/d00/tutorial_py_root.html>OpenCV-Python 教程</a></li><li><a href=https://docs.opencv.ac.cn/4.13.0/d5/d10/tutorial_js_root.html>OpenCV.js 教程</a></li><li><a href=https://docs.opencv.ac.cn/4.13.0/d3/d81/tutorial_contrib_root.html>contrib 模块教程</a></li><li><a href=https://docs.opencv.ac.cn/4.13.0/d3/d2d/faq.html>常见问题解答</a></li><li><a href=https://docs.opencv.ac.cn/4.13.0/d0/de3/citelist.html>参考文献</a></li><li>主模块<ul><li>core. <a href=https://docs.opencv.ac.cn/4.13.0/d0/de1/group__core.html>核心功能</a></li><li>imgproc. <a href=https://docs.opencv.ac.cn/4.13.0/d7/dbd/group__imgproc.html>图像处理</a></li><li>imgcodecs. <a href=https://docs.opencv.ac.cn/4.13.0/d4/da8/group__imgcodecs.html>图像文件读写</a></li><li>videoio. <a href=https://docs.opencv.ac.cn/4.13.0/dd/de7/group__videoio.html>视频 I/O</a></li><li>highgui. <a href=https://docs.opencv.ac.cn/4.13.0/d7/dfc/group__highgui.html>高级 GUI</a></li><li>video. <a href=https://docs.opencv.ac.cn/4.13.0/d7/de9/group__video.html>视频分析</a></li><li>calib3d. <a href=https://docs.opencv.ac.cn/4.13.0/d9/d0c/group__calib3d.html>相机标定与 3D 重建</a></li><li>features2d. <a href=https://docs.opencv.ac.cn/4.13.0/da/d9b/group__features2d.html>2D 特征框架</a></li><li>objdetect. <a href=https://docs.opencv.ac.cn/4.13.0/d5/d54/group__objdetect.html>目标检测</a></li><li>dnn. <a href=https://docs.opencv.ac.cn/4.13.0/d6/d0f/group__dnn.html>深度神经网络模块</a></li><li>ml. <a href=https://docs.opencv.ac.cn/4.13.0/dd/ded/group__ml.html>机器学习</a></li><li>flann. <a href=https://docs.opencv.ac.cn/4.13.0/dc/de5/group__flann.html>多维空间中的聚类与搜索</a></li><li>photo. <a href=https://docs.opencv.ac.cn/4.13.0/d1/d0d/group__photo.html>计算摄影</a></li><li>stitching. <a href=https://docs.opencv.ac.cn/4.13.0/d1/d46/group__stitching.html>图像拼接</a></li><li>gapi. <a href=https://docs.opencv.ac.cn/4.13.0/d0/d1e/gapi.html>图 API</a></li></ul></li><li>扩展模块<ul><li>alphamat. <a href=https://docs.opencv.ac.cn/4.13.0/d4/d40/group__alphamat.html>Alpha 抠图</a></li><li>aruco. <a href=https://docs.opencv.ac.cn/4.13.0/d9/d6a/group__aruco.html>Aruco 标记，模块功能已移至 objdetect 模块</a></li><li>bgsegm. <a href=https://docs.opencv.ac.cn/4.13.0/d2/d55/group__bgsegm.html>改进的背景-前景分割方法</a></li><li>bioinspired. <a href=https://docs.opencv.ac.cn/4.13.0/dd/deb/group__bioinspired.html>受生物启发的视觉模型和衍生工具</a></li><li>cannops. <a href=https://docs.opencv.ac.cn/4.13.0/d6/df4/group__cannops.html>Ascend 加速的计算机视觉</a></li><li>ccalib. <a href=https://docs.opencv.ac.cn/4.13.0/d3/ddc/group__ccalib.html>用于 3D 重建的自定义标定图案</a></li><li>cudaarithm. <a href=https://docs.opencv.ac.cn/4.13.0/d5/d8e/group__cudaarithm.html>矩阵运算</a>Cudaarithm。矩阵运算</li><li>cudabgsegm. <a href=https://docs.opencv.ac.cn/4.13.0/d6/d17/group__cudabgsegm.html>背景分割</a></li><li>cudacodec. <a href=https://docs.opencv.ac.cn/4.13.0/d0/d61/group__cudacodec.html>视频编码/解码</a></li><li>cudafeatures2d. <a href=https://docs.opencv.ac.cn/4.13.0/d6/d1d/group__cudafeatures2d.html>特征检测与描述</a></li><li>cudafilters. <a href=https://docs.opencv.ac.cn/4.13.0/dc/d66/group__cudafilters.html>图像滤波</a></li><li>cudaimgproc. <a href=https://docs.opencv.ac.cn/4.13.0/d0/d05/group__cudaimgproc.html>图像处理</a></li><li>cudalegacy. <a href=https://docs.opencv.ac.cn/4.13.0/d5/dc3/group__cudalegacy.html>遗留支持</a></li><li>cudaobjdetect. <a href=https://docs.opencv.ac.cn/4.13.0/d9/d3f/group__cudaobjdetect.html>目标检测</a></li><li>cudaoptflow. <a href=https://docs.opencv.ac.cn/4.13.0/d7/d3f/group__cudaoptflow.html>光流</a></li><li>cudastereo. <a href=https://docs.opencv.ac.cn/4.13.0/dd/d47/group__cudastereo.html>立体匹配</a></li><li>cudawarping. <a href=https://docs.opencv.ac.cn/4.13.0/db/d29/group__cudawarping.html>图像形变</a></li><li>cudev. <a href=https://docs.opencv.ac.cn/4.13.0/df/dfc/group__cudev.html>设备层</a></li><li>cvv. <a href=https://docs.opencv.ac.cn/4.13.0/df/dff/group__cvv.html>用于计算机视觉程序交互式视觉调试的 GUI</a></li><li>datasets. <a href=https://docs.opencv.ac.cn/4.13.0/d8/d00/group__datasets.html>处理不同数据集的框架</a></li><li>dnn_objdetect. <a href=https://docs.opencv.ac.cn/4.13.0/d5/df6/group__dnn__objdetect.html>用于目标检测的 DNN</a></li><li>dnn_superres. <a href=https://docs.opencv.ac.cn/4.13.0/d9/de0/group__dnn__superres.html>用于超分辨率的 DNN</a></li><li>dpm. <a href=https://docs.opencv.ac.cn/4.13.0/d9/d12/group__dpm.html>可变形部件模型</a></li><li>face. <a href=https://docs.opencv.ac.cn/4.13.0/db/d7c/group__face.html>人脸分析</a></li><li>fastcv. <a href=https://docs.opencv.ac.cn/4.13.0/dc/db8/group__fastcv.html>FastCV 硬件加速函数的模块封装</a></li><li>freetype. <a href=https://docs.opencv.ac.cn/4.13.0/d4/dfc/group__freetype.html>使用 freetype/harfbuzz 绘制 UTF-8 字符串</a></li><li>fuzzy. <a href=https://docs.opencv.ac.cn/4.13.0/df/d5b/group__fuzzy.html>基于模糊数学的图像处理</a></li><li>hdf. <a href=https://docs.opencv.ac.cn/4.13.0/db/d77/group__hdf.html>分层数据格式 I/O 例程</a></li><li>hfs. <a href=https://docs.opencv.ac.cn/4.13.0/dc/d29/group__hfs.html>用于高效图像分割的分层特征选择</a></li><li>img_hash. <a href=https://docs.opencv.ac.cn/4.13.0/d4/d93/group__img__hash.html>该模块提供了不同图像哈希算法的实现。</a></li><li>intensity_transform. <a href=https://docs.opencv.ac.cn/4.13.0/dc/dfe/group__intensity__transform.html>该模块提供了用于调整图像对比度的强度变换算法的实现。</a></li><li>julia. <a href=https://docs.opencv.ac.cn/4.13.0/d7/d44/group__julia.html>OpenCV 的 Julia 绑定</a></li><li>line_descriptor. <a href=https://docs.opencv.ac.cn/4.13.0/dc/ddd/group__line__descriptor.html>从图像中提取的线的二进制描述符</a></li><li>mcc. <a href=https://docs.opencv.ac.cn/4.13.0/dd/d19/group__mcc.html>Macbeth 色卡模块</a></li><li>optflow. <a href=https://docs.opencv.ac.cn/4.13.0/d2/d84/group__optflow.html>光流算法</a></li><li>ovis. <a href=https://docs.opencv.ac.cn/4.13.0/d2/d17/group__ovis.html>OGRE 3D 可视化器</a></li><li>phase_unwrapping. <a href=https://docs.opencv.ac.cn/4.13.0/df/d3a/group__phase__unwrapping.html>相位展开 API</a></li><li>plot. <a href=https://docs.opencv.ac.cn/4.13.0/db/dfe/group__plot.html>Mat 数据的绘图函数</a></li><li>quality. <a href=https://docs.opencv.ac.cn/4.13.0/dc/d20/group__quality.html>图像质量分析 (IQA) API</a></li><li>rapid. <a href=https://docs.opencv.ac.cn/4.13.0/d4/dc4/group__rapid.html>基于轮廓的 3D 对象跟踪</a></li><li>reg. <a href=https://docs.opencv.ac.cn/4.13.0/db/d61/group__reg.html>图像配准</a></li><li>rgbd. <a href=https://docs.opencv.ac.cn/4.13.0/d2/d3a/group__rgbd.html>RGB-D 处理</a></li><li>saliency. <a href=https://docs.opencv.ac.cn/4.13.0/d8/d65/group__saliency.html>显著性 API</a></li><li>sfm. <a href=https://docs.opencv.ac.cn/4.13.0/d8/d8c/group__sfm.html>运动恢复结构</a></li><li>shape. <a href=https://docs.opencv.ac.cn/4.13.0/d1/d85/group__shape.html>形状距离与匹配</a></li><li>signal. <a href=https://docs.opencv.ac.cn/4.13.0/d2/d1f/group__signal.html>信号处理</a></li><li>stereo. <a href=https://docs.opencv.ac.cn/4.13.0/dd/d86/group__stereo.html>立体匹配算法</a></li><li>structured_light. <a href=https://docs.opencv.ac.cn/4.13.0/d1/d90/group__structured__light.html>结构光 API</a></li><li>superres. <a href=https://docs.opencv.ac.cn/4.13.0/d7/d0a/group__superres.html>超分辨率</a></li><li>surface_matching. <a href=https://docs.opencv.ac.cn/4.13.0/d9/d25/group__surface__matching.html>表面匹配</a></li><li>text. <a href=https://docs.opencv.ac.cn/4.13.0/d4/d61/group__text.html>场景文本检测与识别</a></li><li>tracking. <a href=https://docs.opencv.ac.cn/4.13.0/d9/df8/group__tracking.html>跟踪 API</a></li><li>videostab. <a href=https://docs.opencv.ac.cn/4.13.0/d5/d50/group__videostab.html>视频稳定</a></li><li>viz. <a href=https://docs.opencv.ac.cn/4.13.0/d1/d19/group__viz.html>3D 可视化器</a></li><li>wechat_qrcode. <a href=https://docs.opencv.ac.cn/4.13.0/dd/d63/group__wechat__qrcode.html>微信 QR 码检测器，用于检测和解析 QR 码。</a></li><li>xfeatures2d. <a href=https://docs.opencv.ac.cn/4.13.0/d1/db4/group__xfeatures2d.html>额外的 2D 特征框架</a></li><li>ximgproc. <a href=https://docs.opencv.ac.cn/4.13.0/df/d2d/group__ximgproc.html>扩展图像处理</a></li><li>xobjdetect. <a href=https://docs.opencv.ac.cn/4.13.0/d4/d54/group__xobjdetect.html>扩展目标检测</a></li><li>xphoto. <a href=https://docs.opencv.ac.cn/4.13.0/de/daa/group__xphoto.html>额外的照片处理算法</a></li></ul></li></ul><p>OpenCV（Open Source Computer Vision Library）是一个开源的计算机视觉和机器学习软件库。</p><p>OpenCV 由一系列 C 函数和少量 C++ 类构成，同时提供了 Python、Java、MATLAB 等语言的接口。</p><p>OpenCV 提供了大量的计算机视觉算法和图像处理工具，广泛应用于图像和视频的处理、分析以及机器学习领域。</p><p>OpenCV 的设计目标是提供一套简单易用的计算机视觉基础库，帮助开发人员快速构建复杂的视觉应用。</p><p><a href=https://www.runoob.com/opencv/opencv-tutorial.html>OpenCV 教程</a></p><h2 id=书籍简介>书籍简介<a hidden class=anchor aria-hidden=true href=#书籍简介>#</a></h2><p>作者：杨淑莹</p><p>其他责任人：杨淑莹</p><p>出版日期：2024-08-01</p><p>出版社：电子工业出版社</p><p>页数：311</p><h2 id=内容简介>内容简介<a hidden class=anchor aria-hidden=true href=#内容简介>#</a></h2><p>本书介绍了数字图像处理技术和深度学习技术，以及这些技术的应用，全书由12章组成。前九章主要介绍数字图像处理技术，内容包括：Python 环境搭建、位图基础、图像的显示、图像的几何变换、图像灰度变换、图像的平滑处理、图像锐化处理、图像分割及测量、图像的形态学处理，后三章主要介绍深度学习技术，将数字图像处理技术和深度学习技术相结合应用于项目开发，内容包括基于卷积神经网络CNN 模型的汉字识别、基于Faster RCNN 模型的手势识别、基于卷积神经网络CNN 模型的语音识别共三个项目的开发技术。本书仅仅介绍基本的理论知识，同时介绍将理论转化为代码的实现步骤和基于Python 开发工具的编程代码，并且可以将处理前与处理后的图像进行对照比较。实例程序的框架结构简单，代码简洁，使初学Python 者很快就掌握图像处理与图像识别技术。</p><h2 id=作者简介>作者简介<a hidden class=anchor aria-hidden=true href=#作者简介>#</a></h2><p>略</p><h1 id=正文摘录>正文摘录<a hidden class=anchor aria-hidden=true href=#正文摘录>#</a></h1><h2 id=前-言>前 言<a hidden class=anchor aria-hidden=true href=#前-言>#</a></h2><h2 id=第1章-图像处理编程基础>第1章 图像处理编程基础<a hidden class=anchor aria-hidden=true href=#第1章-图像处理编程基础>#</a></h2><h3 id=11-python开发基础>1.1 Python开发基础<a hidden class=anchor aria-hidden=true href=#11-python开发基础>#</a></h3><h4 id=111-python的安装>1.1.1 Python的安装<a hidden class=anchor aria-hidden=true href=#111-python的安装>#</a></h4><h4 id=112-pycharm的安装>1.1.2 PyCharm的安装<a hidden class=anchor aria-hidden=true href=#112-pycharm的安装>#</a></h4><h4 id=113-opencv及常用库的配置>1.1.3 OpenCV及常用库的配置<a hidden class=anchor aria-hidden=true href=#113-opencv及常用库的配置>#</a></h4><h3 id=12-数字图像处理与深度学习技术简介>1.2 数字图像处理与深度学习技术简介<a hidden class=anchor aria-hidden=true href=#12-数字图像处理与深度学习技术简介>#</a></h3><h3 id=13-系统界面开发基础>1.3 系统界面开发基础<a hidden class=anchor aria-hidden=true href=#13-系统界面开发基础>#</a></h3><h3 id=14-图像显示>1.4 图像显示<a hidden class=anchor aria-hidden=true href=#14-图像显示>#</a></h3><h4 id=141-待处理图像的显示>1.4.1 待处理图像的显示<a hidden class=anchor aria-hidden=true href=#141-待处理图像的显示>#</a></h4><h4 id=142-处理后图像的显示>1.4.2 处理后图像的显示<a hidden class=anchor aria-hidden=true href=#142-处理后图像的显示>#</a></h4><h2 id=第2章-彩色图像特效处理>第2章 彩色图像特效处理<a hidden class=anchor aria-hidden=true href=#第2章-彩色图像特效处理>#</a></h2><h3 id=21-图像的颜色表示>2.1 图像的颜色表示<a hidden class=anchor aria-hidden=true href=#21-图像的颜色表示>#</a></h3><h4 id=211-像素的颜色>2.1.1 像素的颜色<a hidden class=anchor aria-hidden=true href=#211-像素的颜色>#</a></h4><h4 id=212-图像的存储结构>2.1.2 图像的存储结构<a hidden class=anchor aria-hidden=true href=#212-图像的存储结构>#</a></h4><p>栅格存储</p><p>位图格式文件扩展名为bmp</p><p>分类：</p><ol><li>单色图像</li><li>8位灰度图像</li><li>8位伪彩色图像</li><li>24位真彩色图像</li></ol><h4 id=213-图像的精度>2.1.3 图像的精度<a hidden class=anchor aria-hidden=true href=#213-图像的精度>#</a></h4><ol><li>空间分辨率</li></ol><p>空间分辨率指图像数字化的空间精细程度，是数字图像中划分图像的像素密度，即单位长度内的像素数，其单位是DPI（Dots Per Inch）。</p><ol start=2><li>灰度级分辨率</li></ol><p>灰度级分辨率表示每一像素的颜色值所占的二进制位数，也叫颜色深度。</p><h3 id=22-彩色图像的灰度化处理>2.2 彩色图像的灰度化处理<a hidden class=anchor aria-hidden=true href=#22-彩色图像的灰度化处理>#</a></h3><p>灰度化处理是使RGB模型中R、G和B分量值相等。常用的转换方式为</p><p>$$Gray(i, j) = 0.11 \times R(i,j) + 0.59\times G(i,j)+0.3\times B(i,j)$$</p><p>灰度化处理还有其他的方法，比如取三个分量的最大值、最小值、算术平均值等，目的都是使R、G和B分量值相等。</p><p>灰度图像只能表示256种颜色，且灰度图像中只有灰度而没有色彩。</p><h3 id=23-彩色图像的着色处理>2.3 彩色图像的着色处理<a hidden class=anchor aria-hidden=true href=#23-彩色图像的着色处理>#</a></h3><p>先灰度化处理，再修改对应的RGB通道值。</p><h3 id=24-彩色图像的亮度调整>2.4 彩色图像的亮度调整<a hidden class=anchor aria-hidden=true href=#24-彩色图像的亮度调整>#</a></h3><p>亮度的调整是指人眼亮度感觉的调整，可以通过对RGB颜色增加或减少相同的增量来显示。</p><h3 id=25-彩色图像的对比度调整>2.5 彩色图像的对比度调整<a hidden class=anchor aria-hidden=true href=#25-彩色图像的对比度调整>#</a></h3><p>增加对比度的意思就是把感兴趣的颜色范围拉开，使得该范围内的像素，其颜色亮的越亮，暗的越暗，从而达到了增强对比度的目的。对比度实际就是颜色分量值之间的差值。调整对比度实际就是对每一颜色分量值的最大值和最小值进行处理。</p><p>增强因子</p><p>阈值法</p><h3 id=26-彩色图像的曝光处理>2.6 彩色图像的曝光处理<a hidden class=anchor aria-hidden=true href=#26-彩色图像的曝光处理>#</a></h3><p>图像曝光或多或少地损失了在原图像中可以看到的那些明快的颜色和色调。曝光处理的效果是基于照片技术的。曝光图像的算法原理是逆转数值小于128的RGB三分量。比如：</p><p>$$g(i,j)=255-f(i,j), if f(i,j)&lt;128$$</p><h3 id=27-彩色图像的马赛克处理>2.7 彩色图像的马赛克处理<a hidden class=anchor aria-hidden=true href=#27-彩色图像的马赛克处理>#</a></h3><p>马赛克效果原理是将图像从形式上划分为很多小块，在每块内的各个像素都取到相同的RGB分量值，从而对某些细节进行模糊化处理，使图像粗糙化。</p><h3 id=28-彩色图像的梯度锐化处理>2.8 彩色图像的梯度锐化处理<a hidden class=anchor aria-hidden=true href=#28-彩色图像的梯度锐化处理>#</a></h3><p>锐化是为了突出图像的变化部分，使模糊的图像变得更加清晰。</p><p>梯度锐化算法原理是将要处理的图像像素与它左对角线上的像素之间的差值乘以一个锐化度数，然后加上原先的像素值，即$new f(i,j) = \frac{1}{4} \times abs(f(i,j), f(i-1,j-1)) + f(i,j)$</p><h3 id=29-彩色图像的浮雕处理>2.9 彩色图像的浮雕处理<a hidden class=anchor aria-hidden=true href=#29-彩色图像的浮雕处理>#</a></h3><p>浮雕效果就是只突出图像的变化部分，而相同颜色部分则被淡化，使图像出现纵深感，从而达到浮雕效果。</p><p>浮雕效果针对灰度图像处理，就是只将图像的变化部分突出出来，而相同灰度部分则被淡化，使图像出现纵深感，从而达到浮雕效果。将要处理的像素取值为与处于前一个相邻像素间的差值，这样灰度平淡区因差值几乎为零则变成黑色，可以通过加上一个常量来增加一些亮度。</p><p>常用方式：$G(i,j) = f(i,j) - f(i-1,j)+constant(128)$</p><p>其中，G(i,j)为处理后图像的像素值，f(i,j)为原图像的像素值，f(i-1,j)为前一个相邻像素的值，常量通常取值为128。</p><h3 id=210-彩色图像的霓虹处理>2.10 彩色图像的霓虹处理<a hidden class=anchor aria-hidden=true href=#210-彩色图像的霓虹处理>#</a></h3><p>霓虹效果用来描绘图像的轮廓，勾画颜色变化的边缘，产生轮廓发光的效果。先计算原图像当前像素f(i,j)的红、绿、蓝分量与其相同行f(i+1,j)及相同列f(i,j+1)相邻像素的梯度，即差的平方和的平方根，然后将梯度值作为处理后像素g(i,j)的红、绿、蓝的3个分量。</p><p><img loading=lazy src=https://cdn.jsdelivr.net/gh/Hanguangwu/MyImageBed01/img/20260110152954843.png></p><p>上式中r1，g1，b1分别为原图像像素f(i,j)的红、绿、蓝分量值，r2,g2,b2分别为原图像同行相邻像素f(i+1,j)的红、绿、蓝分量值，r3,g3,b3分别为原图像同列相邻像素f(i,j+1)的红、绿、蓝分量值，Red，Green，Blue为图像处理后的像素f(i,j)的红、绿、蓝分量值。</p><p><a href=https://blog.csdn.net/weixin_44394801/article/details/118077806>数字图像处理风格化效果——霓虹效果</a></p><h3 id=附录挤压效果>附录——挤压效果<a hidden class=anchor aria-hidden=true href=#附录挤压效果>#</a></h3><p>挤压效果是将图像向内挤压，产生收缩变形。</p><p>挤压效果的实现可以看成是数学极坐标的一种体现，将当前像素点、图像正中心点和过中心点的水平线这三要素画出一个极坐标，然后根据用户指定的挤压度，在当前点与中心点所连的直线上映射出一个像素点，最后将这个像素点作为目标点输出。</p><h2 id=第3章-图像的合成处理>第3章 图像的合成处理<a hidden class=anchor aria-hidden=true href=#第3章-图像的合成处理>#</a></h2><p>图像的合成是指多幅图像之间进行的相互运算。多幅同样大小的图像可以进行代数运算和逻辑运算。</p><h3 id=31-图像的代数运算>3.1 图像的代数运算<a hidden class=anchor aria-hidden=true href=#31-图像的代数运算>#</a></h3><p>图像相加的一个重要应用就是对同一场景的多幅图像求平均值，它可以有效地降低随机噪声的影响。</p><p>图像相减可用于去除一幅图像中不需要的图案，也可以用于检测同一场景的两幅图像之间的变换，例如检测物体运动。</p><p>图像相乘可以遮住图像中的某些部分，仅留下感兴趣的物体。</p><p>图像相除可产生对颜色和多光谱图像分析十分重要的比率图像。</p><h4 id=311-图像加运算>3.1.1 图像加运算<a hidden class=anchor aria-hidden=true href=#311-图像加运算>#</a></h4><h4 id=312-图像减运算>3.1.2 图像减运算<a hidden class=anchor aria-hidden=true href=#312-图像减运算>#</a></h4><h3 id=32-图像的逻辑运算>3.2 图像的逻辑运算<a hidden class=anchor aria-hidden=true href=#32-图像的逻辑运算>#</a></h3><p>以下是一些常见的按位逻辑运算的应用场景：</p><ul><li>图像融合，实现图像的混合、叠加、过渡和融合效果。</li><li>图像分割和掩膜（二进制图像）：可以通过位与运算提取图像中感兴趣的区域，或者通过位或运算将不同的图像部分进行组合。</li><li>图像修复和去除</li><li>图像处理和特征提取：可用于分析和检测图像之间的差异</li><li>图像二值化和阈值操作：分割图像、提取感兴趣的目标</li></ul><h4 id=321-位与运算>3.2.1 位与运算<a hidden class=anchor aria-hidden=true href=#321-位与运算>#</a></h4><h4 id=322-位或运算>3.2.2 位或运算<a hidden class=anchor aria-hidden=true href=#322-位或运算>#</a></h4><h4 id=323-位非运算>3.2.3 位非运算<a hidden class=anchor aria-hidden=true href=#323-位非运算>#</a></h4><h4 id=324-位异或运算>3.2.4 位异或运算<a hidden class=anchor aria-hidden=true href=#324-位异或运算>#</a></h4><h2 id=第4章-图像的几何变换>第4章 图像的几何变换<a hidden class=anchor aria-hidden=true href=#第4章-图像的几何变换>#</a></h2><h3 id=41-概述>4.1 概述<a hidden class=anchor aria-hidden=true href=#41-概述>#</a></h3><p>简单讲，几何变换就是建立变化前后像素之间的映射关系。</p><p>几何变换可以实现图像各像素点以坐标原点为中心的平移、缩放、镜像、旋转等各种变化。一般来说，变换后的点集=变化矩阵T✖变换前的点集矩阵。</p><p>复合变换（级联变换）：基本变换按顺序进行</p><p>常用的图形变换模型有如下三种形式：</p><ul><li>刚体变换：任意两像素点之间距离不变，仅局限在平移、旋转和反转（镜像）</li><li>仿射变换：直线保持平行关系，适用于平移、旋转、缩放和反转（镜像）等情况</li><li>投影变换：直线仍是直线，但基本不再保持平行关系</li></ul><h3 id=42-图像平移>4.2 图像平移<a hidden class=anchor aria-hidden=true href=#42-图像平移>#</a></h3><h3 id=43-图像镜像>4.3 图像镜像<a hidden class=anchor aria-hidden=true href=#43-图像镜像>#</a></h3><h3 id=44-图像缩放>4.4 图像缩放<a hidden class=anchor aria-hidden=true href=#44-图像缩放>#</a></h3><h3 id=45-图像转置>4.5 图像转置<a hidden class=anchor aria-hidden=true href=#45-图像转置>#</a></h3><h3 id=46-投影变换>4.6 投影变换<a hidden class=anchor aria-hidden=true href=#46-投影变换>#</a></h3><h3 id=47-图像旋转>4.7 图像旋转<a hidden class=anchor aria-hidden=true href=#47-图像旋转>#</a></h3><h3 id=小结>小结<a hidden class=anchor aria-hidden=true href=#小结>#</a></h3><p>本章主要解决输入图像位置的标准化及大小的正规化，从而方便进行图像几何校正。</p><p>图像的几何校正主要包括如下两步：</p><p>（1）空间坐标变换。重新排列图像平面上的像素以恢复原有的空间关系。</p><p>（2）灰度值的确定。对空间变换后的像素赋予相应的灰度值，使之恢复原位置的灰度值，称为灰度插值。</p><h2 id=第5章-图像的灰度变换>第5章 图像的灰度变换<a hidden class=anchor aria-hidden=true href=#第5章-图像的灰度变换>#</a></h2><h3 id=51-概述>5.1 概述<a hidden class=anchor aria-hidden=true href=#51-概述>#</a></h3><p>灰度变化目的是改善画质，使图像的显示效果更加清晰。灰度变化可以增大图像的动态范围，扩展图像的对比度，使图像特征变得明显。灰度变化有时又被称为图像的对比度增强或对比度拉伸。</p><p>图像对比度增强的方法可以分为两类：</p><p>（1）直接对比度增强方法</p><p>灰度变化函数</p><p>（2）间接对比度增强方法</p><p>直方图拉伸和直方图均衡化是两种最常见的间接对比度增强方法。</p><h3 id=52-二值化和阈值处理>5.2 二值化和阈值处理<a hidden class=anchor aria-hidden=true href=#52-二值化和阈值处理>#</a></h3><h3 id=53-灰度线性变换与分段线性变换>5.3 灰度线性变换与分段线性变换<a hidden class=anchor aria-hidden=true href=#53-灰度线性变换与分段线性变换>#</a></h3><h4 id=531-灰度线性变换>5.3.1 灰度线性变换<a hidden class=anchor aria-hidden=true href=#531-灰度线性变换>#</a></h4><h4 id=532-分段线性变换>5.3.2 分段线性变换<a hidden class=anchor aria-hidden=true href=#532-分段线性变换>#</a></h4><h3 id=54-灰度非线性变换>5.4 灰度非线性变换<a hidden class=anchor aria-hidden=true href=#54-灰度非线性变换>#</a></h3><h4 id=541-灰度对数变换>5.4.1 灰度对数变换<a hidden class=anchor aria-hidden=true href=#541-灰度对数变换>#</a></h4><h4 id=542-灰度指数变换>5.4.2 灰度指数变换<a hidden class=anchor aria-hidden=true href=#542-灰度指数变换>#</a></h4><h4 id=543-灰度幂次变换>5.4.3 灰度幂次变换<a hidden class=anchor aria-hidden=true href=#543-灰度幂次变换>#</a></h4><h3 id=55-灰度直方图>5.5 灰度直方图<a hidden class=anchor aria-hidden=true href=#55-灰度直方图>#</a></h3><h4 id=551-灰度直方图的概念>5.5.1 灰度直方图的概念<a hidden class=anchor aria-hidden=true href=#551-灰度直方图的概念>#</a></h4><h4 id=552-直方图正规化>5.5.2 直方图正规化<a hidden class=anchor aria-hidden=true href=#552-直方图正规化>#</a></h4><h4 id=553-直方图均衡化>5.5.3 直方图均衡化<a hidden class=anchor aria-hidden=true href=#553-直方图均衡化>#</a></h4><h4 id=554-自适应直方图均衡化>5.5.4 自适应直方图均衡化<a hidden class=anchor aria-hidden=true href=#554-自适应直方图均衡化>#</a></h4><h2 id=第6章-图像平滑处理>第6章 图像平滑处理<a hidden class=anchor aria-hidden=true href=#第6章-图像平滑处理>#</a></h2><h3 id=61-概述>6.1 概述<a hidden class=anchor aria-hidden=true href=#61-概述>#</a></h3><p>图像平滑滤波的目的是消除噪声，保留有用信号，降低干扰，改善图像质量。同时，在提取较大目标前，去除太小的细节，或将目标内的小间断连接起来，平滑滤波也起到模糊作用。平滑滤波使图像的低频分量增强，同时削弱高频分量，用于消除图像中的随机噪声，起到平滑作用。</p><p>对图像像素的处理方式可以划分为点处理和区域处理。</p><p>图像平滑常用的方法是采用区域处理，利用相邻的像素值进行均值滤波或中值滤波。</p><h3 id=62-噪声消除法>6.2 噪声消除法<a hidden class=anchor aria-hidden=true href=#62-噪声消除法>#</a></h3><h4 id=621-二值图像的黑白点噪声滤波>6.2.1 二值图像的黑白点噪声滤波<a hidden class=anchor aria-hidden=true href=#621-二值图像的黑白点噪声滤波>#</a></h4><h4 id=622-消除孤立黑像素点>6.2.2 消除孤立黑像素点<a hidden class=anchor aria-hidden=true href=#622-消除孤立黑像素点>#</a></h4><h3 id=63-邻域平均法>6.3 邻域平均法<a hidden class=anchor aria-hidden=true href=#63-邻域平均法>#</a></h3><p>邻域平均法是一种利用模板对图像进行模板操作（卷积运算）的方法。</p><p>均值滤波器对高斯噪声的滤波效果较好，对椒盐噪声的滤波效果不好。原因:</p><ul><li>高斯噪声均值为0</li><li>椒盐噪声随机分布在不同的位置上，图像中有干净点也有污染点，噪声的均值不为0</li></ul><p>邻域平均法通过一点和邻域内像素点求平均值来去除突变的像素点，优点是算法简单，计算速度快，代价是会造成图像一定程度上的模糊。</p><h4 id=631-3-3均值滤波>6.3.1 3 ×3均值滤波<a hidden class=anchor aria-hidden=true href=#631-3-3均值滤波>#</a></h4><h4 id=632-nn均值滤波>6.3.2 N×N均值滤波<a hidden class=anchor aria-hidden=true href=#632-nn均值滤波>#</a></h4><h4 id=633-超限邻域平均法>6.3.3 超限邻域平均法<a hidden class=anchor aria-hidden=true href=#633-超限邻域平均法>#</a></h4><h4 id=634-方框滤波>6.3.4 方框滤波<a hidden class=anchor aria-hidden=true href=#634-方框滤波>#</a></h4><h3 id=64-高斯滤波>6.4 高斯滤波<a hidden class=anchor aria-hidden=true href=#64-高斯滤波>#</a></h3><p>高斯滤波中卷积核中的值按照距离中心点的远近分别赋予不同的权重值。</p><h3 id=65-中值滤波>6.5 中值滤波<a hidden class=anchor aria-hidden=true href=#65-中值滤波>#</a></h3><p>邻域平均法属于低通滤波的处理方法。它在抑制噪声的同时使图像变得模糊，即图像的细节（例如边缘信息）被削弱，因而造成视觉上的失真。如果目的只是把干扰去除，而不是刻意让图像模糊，那么中值滤波能够抑制噪声又可以保持细节，是比较好的选择。</p><h4 id=651-nn中值滤波>6.5.1 N×N中值滤波<a hidden class=anchor aria-hidden=true href=#651-nn中值滤波>#</a></h4><h4 id=652-十字形中值滤波>6.5.2 十字形中值滤波<a hidden class=anchor aria-hidden=true href=#652-十字形中值滤波>#</a></h4><h4 id=653-nn最大值滤波>6.5.3 N×N最大值滤波<a hidden class=anchor aria-hidden=true href=#653-nn最大值滤波>#</a></h4><h3 id=66-双边滤波>6.6 双边滤波<a hidden class=anchor aria-hidden=true href=#66-双边滤波>#</a></h3><p>双边滤波可以有效保护图像的边缘信息。</p><h3 id=67--2d卷积核的实现>6.7 2D卷积核的实现<a hidden class=anchor aria-hidden=true href=#67--2d卷积核的实现>#</a></h3><p>自定义卷积核实现图像的平滑处理。可以使用<code>cv2.filter2D()</code>。</p><h3 id=68-加噪声处理>6.8 加噪声处理<a hidden class=anchor aria-hidden=true href=#68-加噪声处理>#</a></h3><h4 id=681-随机噪声>6.8.1 随机噪声<a hidden class=anchor aria-hidden=true href=#681-随机噪声>#</a></h4><h4 id=682-椒盐噪声>6.8.2 椒盐噪声<a hidden class=anchor aria-hidden=true href=#682-椒盐噪声>#</a></h4><h2 id=第7章-图像边缘锐化处理>第7章 图像边缘锐化处理<a hidden class=anchor aria-hidden=true href=#第7章-图像边缘锐化处理>#</a></h2><p>在图像处理中，平滑处理（也称为模糊处理）是一种常见的操作，用于减少图像中的噪声或细节。</p><p>OpenCV 提供了多种平滑处理的方法，本文将详细讲解四种常用的平滑处理技术：均值滤波、高斯滤波、中值滤波和双边滤波。</p><h3 id=71-概述>7.1 概述<a hidden class=anchor aria-hidden=true href=#71-概述>#</a></h3><p>从本质上说，图像边缘是图像局部特性不连续性（灰度突变、颜色突变等）的反映，它标志着一个区域的终结和另一个区域的开始。边缘提取首先检出图像局部特性的不连续性，然后再将这些不连续的边缘像素连成完整的边界。边缘的特性是沿边缘走向的像素变化平缓，而垂直于边缘方向的像素变化剧烈。</p><p>图像平滑往往使图像中的边界、轮廓变得模糊，而且单纯的微分运算会使低频成分损失很多，为了减少这类不利效果的影响，不丢失低频信息，提升边缘强度，这就需要利用图像边缘锐化技术，使边缘变得清晰。图像锐化处理也被称为高频提升滤波器。利用边缘检测方法求出边缘后，对边缘求梯度，将原图像和梯度图像叠加在一起，内容完整保留，而突出高频成分，同时，具有边缘锐化处理的效果。</p><h3 id=72-图像微分边缘检测>7.2 图像微分边缘检测<a hidden class=anchor aria-hidden=true href=#72-图像微分边缘检测>#</a></h3><h4 id=721-纵向微分边缘检测>7.2.1 纵向微分边缘检测<a hidden class=anchor aria-hidden=true href=#721-纵向微分边缘检测>#</a></h4><h4 id=722-横向微分边缘检测>7.2.2 横向微分边缘检测<a hidden class=anchor aria-hidden=true href=#722-横向微分边缘检测>#</a></h4><h4 id=723-双向一次微分边缘检测>7.2.3 双向一次微分边缘检测<a hidden class=anchor aria-hidden=true href=#723-双向一次微分边缘检测>#</a></h4><h3 id=73-常用的边缘检测算子及方法>7.3 常用的边缘检测算子及方法<a hidden class=anchor aria-hidden=true href=#73-常用的边缘检测算子及方法>#</a></h3><h4 id=731-roberts边缘检测算子>7.3.1 Roberts边缘检测算子<a hidden class=anchor aria-hidden=true href=#731-roberts边缘检测算子>#</a></h4><h4 id=732-sobel边缘检测算子>7.3.2 Sobel边缘检测算子<a hidden class=anchor aria-hidden=true href=#732-sobel边缘检测算子>#</a></h4><h4 id=733-prewitt边缘检测算子>7.3.3 Prewitt边缘检测算子<a hidden class=anchor aria-hidden=true href=#733-prewitt边缘检测算子>#</a></h4><h4 id=734-scharr边缘检测算子>7.3.4 Scharr边缘检测算子<a hidden class=anchor aria-hidden=true href=#734-scharr边缘检测算子>#</a></h4><h4 id=735-krisch自适应边缘检测>7.3.5 Krisch自适应边缘检测<a hidden class=anchor aria-hidden=true href=#735-krisch自适应边缘检测>#</a></h4><h4 id=736-laplacian算子>7.3.6 Laplacian算子<a hidden class=anchor aria-hidden=true href=#736-laplacian算子>#</a></h4><h4 id=737-log算子>7.3.7 LoG算子<a hidden class=anchor aria-hidden=true href=#737-log算子>#</a></h4><h4 id=738-canny边缘检测>7.3.8 Canny边缘检测<a hidden class=anchor aria-hidden=true href=#738-canny边缘检测>#</a></h4><h3 id=74-梯度锐化>7.4 梯度锐化<a hidden class=anchor aria-hidden=true href=#74-梯度锐化>#</a></h3><h4 id=741-提升边缘>7.4.1 提升边缘<a hidden class=anchor aria-hidden=true href=#741-提升边缘>#</a></h4><h4 id=742-根据梯度二值化图像>7.4.2 根据梯度二值化图像<a hidden class=anchor aria-hidden=true href=#742-根据梯度二值化图像>#</a></h4><h2 id=第8章-图像形态学处理>第8章 图像形态学处理<a hidden class=anchor aria-hidden=true href=#第8章-图像形态学处理>#</a></h2><h3 id=81-概述>8.1 概述<a hidden class=anchor aria-hidden=true href=#81-概述>#</a></h3><p>目标和结构元素（刷子）是形态学的基本术语。</p><p>形态学图像处理通常表现为一种邻域运算形式，在每个像素位置上邻域结构元素与二值图像对应的区域进行特定的逻辑运算，逻辑运算的结果为输出图像的相应元素。</p><p>数学形态学最常见的基本运算有七种，分别为腐蚀、膨胀、开运算、闭运算、细化、黑帽和礼帽运算。用这些运算及其组合可以进行图像形状和结构的分析与处理，包括图像分割、特征抽取、边缘检测、图像滤波、图像增强和恢复等方面的工作。</p><p>图像形态学操作是图像处理中的一种重要技术，主要用于处理二值图像（即黑白图像）。</p><p>OpenCV 中的图像形态学操作是图像处理中的重要工具，通过腐蚀、膨胀、开运算、闭运算和形态学梯度等操作，可以实现对图像的噪声去除、对象分离、边缘检测等效果。掌握这些操作有助于更好地处理和分析图像数据。</p><p>以下是 OpenCV 中常用的形态学操作及其函数：</p><table><thead><tr><th><strong>操作</strong></th><th><strong>函数</strong></th><th><strong>说明</strong></th><th><strong>应用场景</strong></th></tr></thead><tbody><tr><td><strong>腐蚀</strong></td><td><code>cv2.erode()</code></td><td>用结构元素扫描图像，如果结构元素覆盖的区域全是前景，则保留中心像素。</td><td>去除噪声、分离物体。</td></tr><tr><td><strong>膨胀</strong></td><td><code>cv2.dilate()</code></td><td>用结构元素扫描图像，如果结构元素覆盖的区域存在前景，则保留中心像素。</td><td>连接断裂的物体、填充空洞。</td></tr><tr><td><strong>开运算</strong></td><td><code>cv2.morphologyEx()</code></td><td>先腐蚀后膨胀。</td><td>去除小物体、平滑物体边界。</td></tr><tr><td><strong>闭运算</strong></td><td><code>cv2.morphologyEx()</code></td><td>先膨胀后腐蚀。</td><td>填充小孔洞、连接邻近物体。</td></tr><tr><td><strong>形态学梯度</strong></td><td><code>cv2.morphologyEx()</code></td><td>膨胀图减去腐蚀图。</td><td>提取物体边缘。</td></tr><tr><td><strong>顶帽运算</strong></td><td><code>cv2.morphologyEx()</code></td><td>原图减去开运算结果。</td><td>提取比背景亮的细小物体。</td></tr><tr><td><strong>黑帽运算</strong></td><td><code>cv2.morphologyEx()</code></td><td>闭运算结果减去原图。</td><td>提取比背景暗的细小物体。</td></tr></tbody></table><h3 id=82-图像腐蚀>8.2 图像腐蚀<a hidden class=anchor aria-hidden=true href=#82-图像腐蚀>#</a></h3><p>作用：消除物体边界点，使边界向内收缩，可以去除小于结构元素的物体。</p><h4 id=821-水平腐蚀>8.2.1 水平腐蚀<a hidden class=anchor aria-hidden=true href=#821-水平腐蚀>#</a></h4><h4 id=822-垂直腐蚀>8.2.2 垂直腐蚀<a hidden class=anchor aria-hidden=true href=#822-垂直腐蚀>#</a></h4><h4 id=823-全方向腐蚀>8.2.3 全方向腐蚀<a hidden class=anchor aria-hidden=true href=#823-全方向腐蚀>#</a></h4><h3 id=83-图像膨胀>8.3 图像膨胀<a hidden class=anchor aria-hidden=true href=#83-图像膨胀>#</a></h3><p>作用：对二值化物体的边界点进行扩充，将与物体边界点接触的所有背景点合并到该物体中，从而使边界向外部扩张。</p><h4 id=831-水平膨胀>8.3.1 水平膨胀<a hidden class=anchor aria-hidden=true href=#831-水平膨胀>#</a></h4><h4 id=832-垂直膨胀>8.3.2 垂直膨胀<a hidden class=anchor aria-hidden=true href=#832-垂直膨胀>#</a></h4><h4 id=833-全方向膨胀>8.3.3 全方向膨胀<a hidden class=anchor aria-hidden=true href=#833-全方向膨胀>#</a></h4><h3 id=84-图像开运算与闭运算>8.4 图像开运算与闭运算<a hidden class=anchor aria-hidden=true href=#84-图像开运算与闭运算>#</a></h3><h4 id=841-图像开运算>8.4.1 图像开运算<a hidden class=anchor aria-hidden=true href=#841-图像开运算>#</a></h4><p>开运算：先腐蚀再膨胀</p><p>腐蚀和膨胀不是一对互逆的操作。</p><p>作用：去除孤立的小点等，平滑处理较大物体的边界，同时并不明显改变其面积</p><h4 id=842-图像闭运算>8.4.2 图像闭运算<a hidden class=anchor aria-hidden=true href=#842-图像闭运算>#</a></h4><p>闭运算：先膨胀后腐蚀</p><p>功能：填充物体内细小空洞，连接邻近物体，平滑其边界，同时并不明显改变其面积</p><h3 id=85-形态学梯度运算>8.5 形态学梯度运算<a hidden class=anchor aria-hidden=true href=#85-形态学梯度运算>#</a></h3><p>形态学梯度运算是利用图像的碰撞图像减去腐蚀图像的一种形态学操作，这种操作可以获得图像的边缘信息。</p><h3 id=86-黑帽与礼帽运算>8.6 黑帽与礼帽运算<a hidden class=anchor aria-hidden=true href=#86-黑帽与礼帽运算>#</a></h3><p>黑帽运算：原始图像减去闭运算的结果</p><p>作用：获得比原始图像边缘更加黑暗的边缘部分，或者获得图像内部的小孔</p><p>礼帽运算：原始图像减去开运算的结果</p><p>作用：获得图像的噪声信息或者比原始图像边缘更亮的边缘部分</p><h3 id=87-图像细化>8.7 图像细化<a hidden class=anchor aria-hidden=true href=#87-图像细化>#</a></h3><p>图像细化其实就是求图像骨架。图像骨架是二维二值目标的重要拓扑描述，指图像中央的骨骼部分，是描述图像几何及拓扑性质的重要特征之一。</p><p>细化的目的就是在将图像的骨架提取出来并保持图像细小部分的连通性。对图像进行细化处理有助于突出形状特点和减少冗余信息。</p><h2 id=第9章-图像分割与测量>第9章 图像分割与测量<a hidden class=anchor aria-hidden=true href=#第9章-图像分割与测量>#</a></h2><h3 id=91-概述>9.1 概述<a hidden class=anchor aria-hidden=true href=#91-概述>#</a></h3><p>图像分割与测量是图像识别工作的基础，分割的目的是将图像分为一些有意义的区域，如目标区域或前景区域，然后可以对这些区域进行描述，相当于提取出某些目标区域图像的特征。</p><p>图像分割的基础是像素间的相似性和跳变性。</p><p>图像分割依据工作对象可以分为点相关分割和区域相关分割。</p><p>本章介绍图像分割的基本方法、轮廓提取方法、目标区域的标识、面积测量和周长测量。</p><h3 id=92-阈值法分割>9.2 阈值法分割<a hidden class=anchor aria-hidden=true href=#92-阈值法分割>#</a></h3><h4 id=921-直方图门限选择法>9.2.1 直方图门限选择法<a hidden class=anchor aria-hidden=true href=#921-直方图门限选择法>#</a></h4><h4 id=922-半阈值选择法>9.2.2 半阈值选择法<a hidden class=anchor aria-hidden=true href=#922-半阈值选择法>#</a></h4><h4 id=923-迭代阈值法>9.2.3 迭代阈值法<a hidden class=anchor aria-hidden=true href=#923-迭代阈值法>#</a></h4><h4 id=924-otsu阈值法>9.2.4 Otsu阈值法<a hidden class=anchor aria-hidden=true href=#924-otsu阈值法>#</a></h4><h4 id=925-自适应阈值法>9.2.5 自适应阈值法<a hidden class=anchor aria-hidden=true href=#925-自适应阈值法>#</a></h4><h4 id=926-分水岭算法>9.2.6 分水岭算法<a hidden class=anchor aria-hidden=true href=#926-分水岭算法>#</a></h4><p>模拟水流通过地形起伏的现象</p><h3 id=93-投影法分割>9.3 投影法分割<a hidden class=anchor aria-hidden=true href=#93-投影法分割>#</a></h3><h4 id=931-水平投影分割>9.3.1 水平投影分割<a hidden class=anchor aria-hidden=true href=#931-水平投影分割>#</a></h4><h4 id=932-垂直投影分割>9.3.2 垂直投影分割<a hidden class=anchor aria-hidden=true href=#932-垂直投影分割>#</a></h4><h3 id=94-轮廓检测>9.4 轮廓检测<a hidden class=anchor aria-hidden=true href=#94-轮廓检测>#</a></h3><h4 id=941-邻域判断法>9.4.1 邻域判断法<a hidden class=anchor aria-hidden=true href=#941-邻域判断法>#</a></h4><p>内部像素点可以删除</p><h4 id=942-边界跟踪法>9.4.2 边界跟踪法<a hidden class=anchor aria-hidden=true href=#942-边界跟踪法>#</a></h4><h4 id=943-区域生长法>9.4.3 区域生长法<a hidden class=anchor aria-hidden=true href=#943-区域生长法>#</a></h4><p>将具有相似性质的像素集合起来构成区域</p><h4 id=944-轮廓检测与拟合>9.4.4 轮廓检测与拟合<a hidden class=anchor aria-hidden=true href=#944-轮廓检测与拟合>#</a></h4><h3 id=95-目标物体测量>9.5 目标物体测量<a hidden class=anchor aria-hidden=true href=#95-目标物体测量>#</a></h3><h4 id=951-区域标记>9.5.1 区域标记<a hidden class=anchor aria-hidden=true href=#951-区域标记>#</a></h4><h4 id=952-面积测量>9.5.2 面积测量<a hidden class=anchor aria-hidden=true href=#952-面积测量>#</a></h4><h4 id=953-周长测量>9.5.3 周长测量<a hidden class=anchor aria-hidden=true href=#953-周长测量>#</a></h4><h3 id=96-最小外包形状检测>9.6 最小外包形状检测<a hidden class=anchor aria-hidden=true href=#96-最小外包形状检测>#</a></h3><h4 id=961-最小外包矩形>9.6.1 最小外包矩形<a hidden class=anchor aria-hidden=true href=#961-最小外包矩形>#</a></h4><h4 id=962-最小外包圆形>9.6.2 最小外包圆形<a hidden class=anchor aria-hidden=true href=#962-最小外包圆形>#</a></h4><h4 id=963-最小外包三角形>9.6.3 最小外包三角形<a hidden class=anchor aria-hidden=true href=#963-最小外包三角形>#</a></h4><h4 id=964-最小外包椭圆形>9.6.4 最小外包椭圆形<a hidden class=anchor aria-hidden=true href=#964-最小外包椭圆形>#</a></h4><h3 id=97-霍夫检测>9.7 霍夫检测<a hidden class=anchor aria-hidden=true href=#97-霍夫检测>#</a></h3><p>霍夫变换是一种特征提取(feature extraction)，被广泛应用在图像分析（image analysis）、计算机视觉(computer vision)以及数位影像处理(digital image processing)。霍夫变换是用来辨别找出物件中的特征，例如：线条。他的算法流程大致如下，给定一个物件、要辨别的形状的种类，算法会在参数空间(parameter space)中执行投票来决定物体的形状，而这是由累加空间(accumulator space)里的局部最大值(local maximum)来决定。</p><p>现在广泛使用的霍夫变换是由Richard Duda和Peter Hart在1972年发明，并称之为广义霍夫变换(generalized Hough transform)，广义霍夫变换和更早前1962年的Paul Hough的专利有关。经典的霍夫变换是侦测图片中的直线，之后，霍夫变换不仅能识别直线，也能够识别任何形状，常见的有圆形、椭圆形。1981年，因为Dana H. Ballard的一篇期刊论文"Generalizing the Hough transform to detect arbitrary shapes"，让霍夫变换开始流行于计算机视觉界。</p><h4 id=971-霍夫直线检测>9.7.1 霍夫直线检测<a hidden class=anchor aria-hidden=true href=#971-霍夫直线检测>#</a></h4><h4 id=972-霍夫圆检测>9.7.2 霍夫圆检测<a hidden class=anchor aria-hidden=true href=#972-霍夫圆检测>#</a></h4><h2 id=第10章-图像频域变换处理>第10章 图像频域变换处理<a hidden class=anchor aria-hidden=true href=#第10章-图像频域变换处理>#</a></h2><h3 id=101-图像频域变换>10.1 图像频域变换<a hidden class=anchor aria-hidden=true href=#101-图像频域变换>#</a></h3><p>图像频域变换是指图像从空域转换到频域的数学变换。常用的频域变换是傅里叶变换和离散余弦变换。</p><p>频率的大小反映了信号变化的快慢。</p><p>在图像处理中，图像的频率是表征图像中灰度变化剧烈程度的指标，是灰度在平面空间上的梯度，也就是图像灰度的变化速度。对图像而言，图像的边缘部分是突变部分，变化较快，因此反映在频域上是高频分量，图像的噪声在大部分情况下也是高频分量；图像平缓变化部分则为低频分量。高频分量解释信号的突变部分，而低频分量决定信号的“整体形象”。</p><h4 id=1011-图像傅里叶变换>10.1.1 图像傅里叶变换<a hidden class=anchor aria-hidden=true href=#1011-图像傅里叶变换>#</a></h4><h4 id=1012-图像快速傅里叶变换>10.1.2 图像快速傅里叶变换<a hidden class=anchor aria-hidden=true href=#1012-图像快速傅里叶变换>#</a></h4><h4 id=1013-图像离散余弦变换>10.1.3 图像离散余弦变换<a hidden class=anchor aria-hidden=true href=#1013-图像离散余弦变换>#</a></h4><h4 id=1014-图像频域变换原理>10.1.4 图像频域变换原理<a hidden class=anchor aria-hidden=true href=#1014-图像频域变换原理>#</a></h4><p>傅里叶变换的物理意义是将图像的灰度分布函数变换为图像的频率分布函数。</p><h3 id=102-频域低通滤波>10.2 频域低通滤波<a hidden class=anchor aria-hidden=true href=#102-频域低通滤波>#</a></h3><h4 id=1021-理想低通滤波>10.2.1 理想低通滤波<a hidden class=anchor aria-hidden=true href=#1021-理想低通滤波>#</a></h4><h4 id=1022-梯形低通滤波>10.2.2 梯形低通滤波<a hidden class=anchor aria-hidden=true href=#1022-梯形低通滤波>#</a></h4><h4 id=1023-巴特沃思低通滤波>10.2.3 巴特沃思低通滤波<a hidden class=anchor aria-hidden=true href=#1023-巴特沃思低通滤波>#</a></h4><h4 id=1024-指数低通滤波>10.2.4 指数低通滤波<a hidden class=anchor aria-hidden=true href=#1024-指数低通滤波>#</a></h4><h3 id=103-频域高通滤波>10.3 频域高通滤波<a hidden class=anchor aria-hidden=true href=#103-频域高通滤波>#</a></h3><h4 id=1031-理想高通滤波>10.3.1 理想高通滤波<a hidden class=anchor aria-hidden=true href=#1031-理想高通滤波>#</a></h4><h4 id=1032-梯形高通滤波>10.3.2 梯形高通滤波<a hidden class=anchor aria-hidden=true href=#1032-梯形高通滤波>#</a></h4><h4 id=1033-巴特沃思高通滤波>10.3.3 巴特沃思高通滤波<a hidden class=anchor aria-hidden=true href=#1033-巴特沃思高通滤波>#</a></h4><h4 id=1034-指数高通滤波>10.3.4 指数高通滤波<a hidden class=anchor aria-hidden=true href=#1034-指数高通滤波>#</a></h4><h2 id=第11章-基于深度学习cnn模型的汉字识别>第11章 基于深度学习CNN模型的汉字识别<a hidden class=anchor aria-hidden=true href=#第11章-基于深度学习cnn模型的汉字识别>#</a></h2><h3 id=111-深度学习技术概述>11.1 深度学习技术概述<a hidden class=anchor aria-hidden=true href=#111-深度学习技术概述>#</a></h3><h3 id=112-cnn基本概念>11.2 CNN基本概念<a hidden class=anchor aria-hidden=true href=#112-cnn基本概念>#</a></h3><p>滤波器是用于在卷积操作中提取特征的小矩阵（卷积核）。</p><h3 id=113-汉字识别系统设计>11.3 汉字识别系统设计<a hidden class=anchor aria-hidden=true href=#113-汉字识别系统设计>#</a></h3><h3 id=114-汉字图像预处理>11.4 汉字图像预处理<a hidden class=anchor aria-hidden=true href=#114-汉字图像预处理>#</a></h3><p>预处理的步骤：</p><ol><li>获取需要获取的图像</li><li>进行灰度化、二值化处理</li><li>进行腐蚀、膨胀处理。腐蚀在数学形态学中的作用是消除噪声，是使边界向内部收缩的过程，可以把小于结构元素的物体去除。膨胀在数学形态中的作用与腐蚀的作用相反，它是对二值化边界点进行扩充，使边界向外部扩张的过程，使得断裂的笔画连接起来。</li><li>进行投影和分割。</li><li>保持分割后的图像。</li></ol><h3 id=115-投影与分割>11.5 投影与分割<a hidden class=anchor aria-hidden=true href=#115-投影与分割>#</a></h3><h3 id=116-构建汉字识别模型>11.6 构建汉字识别模型<a hidden class=anchor aria-hidden=true href=#116-构建汉字识别模型>#</a></h3><h4 id=1161-构建cnn模型>11.6.1 构建CNN模型<a hidden class=anchor aria-hidden=true href=#1161-构建cnn模型>#</a></h4><h4 id=1162-识别模型训练>11.6.2 识别模型训练<a hidden class=anchor aria-hidden=true href=#1162-识别模型训练>#</a></h4><h3 id=117-汉字识别模型检验>11.7 汉字识别模型检验<a hidden class=anchor aria-hidden=true href=#117-汉字识别模型检验>#</a></h3><h2 id=第12章-基于深度学习cnn模型的语音识别>第12章 基于深度学习CNN模型的语音识别<a hidden class=anchor aria-hidden=true href=#第12章-基于深度学习cnn模型的语音识别>#</a></h2><p>语音识别模型训练采用的经典方法为提取语音信号的MFCC（梅尔倒谱系数）特征，使用HMM对MFCC特征进行训练。</p><p>本模板采用的是语音信号的MFCC特征和CNN来进行模型训练。</p><h3 id=121-语音识别系统设计>12.1 语音识别系统设计<a hidden class=anchor aria-hidden=true href=#121-语音识别系统设计>#</a></h3><h3 id=122-语音信号预处理及特征提取>12.2 语音信号预处理及特征提取<a hidden class=anchor aria-hidden=true href=#122-语音信号预处理及特征提取>#</a></h3><h4 id=1221-语音信号预处理>12.2.1 语音信号预处理<a hidden class=anchor aria-hidden=true href=#1221-语音信号预处理>#</a></h4><p>实现步骤：</p><ol><li>获取语音信号</li><li>语音信号预加重</li><li>语音信号分帧</li><li>语音信号加窗</li><li>语音信号快速傅里叶变换</li></ol><h4 id=1222-mfcc特征提取>12.2.2 MFCC特征提取<a hidden class=anchor aria-hidden=true href=#1222-mfcc特征提取>#</a></h4><p>提取步骤：</p><ol><li>获取语音信号</li><li>语音信号预加重</li><li>语音信号分帧</li><li>语音信号加窗</li><li>语音信号快速傅里叶变换</li><li>语音信号的频谱数据通过三角带通滤波器</li><li>三角带通滤波器输出结果对数运算</li><li>对对数运算结果进行离散余弦变换，得到MFCC特征矩阵</li><li>根据MFCC特征矩阵值把特征矩阵转换为图像</li></ol><h3 id=123-构建语音识别模型>12.3 构建语音识别模型<a hidden class=anchor aria-hidden=true href=#123-构建语音识别模型>#</a></h3><h4 id=1231-构建cnn模型>12.3.1 构建CNN模型<a hidden class=anchor aria-hidden=true href=#1231-构建cnn模型>#</a></h4><h4 id=1232-识别模型训练>12.3.2 识别模型训练<a hidden class=anchor aria-hidden=true href=#1232-识别模型训练>#</a></h4><h3 id=124-语音识别模型检验>12.4 语音识别模型检验<a hidden class=anchor aria-hidden=true href=#124-语音识别模型检验>#</a></h3><p>语音识别步骤：</p><ol><li>获取待识别语音</li><li>语音信号预处理及MFCC特征提取</li><li>将MFCC特征矩阵转换为图像</li><li>将语音信号输入已经训练好的卷积神经网络中</li><li>将识别结果（拼音）转为漢字结果</li></ol><h2 id=第13章-基于深度学习faster-r-cnn模型的手势识别>第13章 基于深度学习Faster R-CNN模型的手势识别<a hidden class=anchor aria-hidden=true href=#第13章-基于深度学习faster-r-cnn模型的手势识别>#</a></h2><h3 id=131-r-cnn目标检测与识别模型>13.1 R-CNN目标检测与识别模型<a hidden class=anchor aria-hidden=true href=#131-r-cnn目标检测与识别模型>#</a></h3><h3 id=132-边框回归原理>13.2 边框回归原理<a hidden class=anchor aria-hidden=true href=#132-边框回归原理>#</a></h3><p>多元线性回归方程</p><h3 id=133-faster-r-cnn目标检测与识别模型>13.3 Faster R-CNN目标检测与识别模型<a hidden class=anchor aria-hidden=true href=#133-faster-r-cnn目标检测与识别模型>#</a></h3><h4 id=1331-faster-r-cnn模型框架>13.3.1 Faster R-CNN模型框架<a hidden class=anchor aria-hidden=true href=#1331-faster-r-cnn模型框架>#</a></h4><h4 id=1332-基于区域提议网络的目标检测>13.3.2 基于区域提议网络的目标检测<a hidden class=anchor aria-hidden=true href=#1332-基于区域提议网络的目标检测>#</a></h4><h4 id=1333-基于roi池化和分类技术的目标识别>13.3.3 基于RoI池化和分类技术的目标识别<a hidden class=anchor aria-hidden=true href=#1333-基于roi池化和分类技术的目标识别>#</a></h4><h3 id=134-手势识别系统设计>13.4 手势识别系统设计<a hidden class=anchor aria-hidden=true href=#134-手势识别系统设计>#</a></h3><h3 id=135-构建手势识别模型>13.5 构建手势识别模型<a hidden class=anchor aria-hidden=true href=#135-构建手势识别模型>#</a></h3><h4 id=1351-构建faster-r-cnn模型>13.5.1 构建Faster R-CNN模型<a hidden class=anchor aria-hidden=true href=#1351-构建faster-r-cnn模型>#</a></h4><ol><li>搭建提取主干特征的卷积神经网络</li><li>搭建检测目标的RPN网络</li><li>搭建RoI池化层</li></ol><h4 id=1352-faster-r-cnn识别模型训练>13.5.2 Faster R-CNN识别模型训练<a hidden class=anchor aria-hidden=true href=#1352-faster-r-cnn识别模型训练>#</a></h4><ol><li>主干特征提取</li><li>锚框贴标签</li><li>计算损失函数</li><li>RPN生成RoI</li></ol><h3 id=136-手势识别模型检验>13.6 手势识别模型检验<a hidden class=anchor aria-hidden=true href=#136-手势识别模型检验>#</a></h3></div><footer class=post-footer><ul class=post-tags><li><a href=https://rosefinch-midsummer.github.io/zh/tags/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/>数字图像处理</a></li></ul><nav class=paginav><a class=prev href=https://rosefinch-midsummer.github.io/zh/posts/book/%E5%8D%A1%E7%89%87%E7%AC%94%E8%AE%B0%E5%86%99%E4%BD%9C%E6%B3%95/><span class=title>« 上一頁</span><br><span>《卡片笔记写作法》</span>
</a><a class=next href=https://rosefinch-midsummer.github.io/zh/posts/book/%E8%BF%99%E4%B8%96%E7%95%8C%E6%97%A2%E6%AE%8B%E9%85%B7%E4%B9%9F%E6%B8%A9%E6%9F%94/><span class=title>下一頁 »</span><br><span>《这世界既残酷也温柔》</span></a></nav></footer><div><div class=pagination__title><span class=pagination__title-h style=font-size:20px>评论</span><br></div><div id=tcomment></div><script src=https://utteranc.es/client.js repo=Rosefinch-Midsummer/comments_of_blog issue-term=title theme=github-light crossorigin=anonymous async></script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.body.className.includes("dark")?"github-light":"photon-dark",t={type:"set-theme",theme:e},n=document.querySelector(".utterances-frame");n.contentWindow.postMessage(t,"https://utteranc.es")})</script></div></article></main><footer class=footer><span>&copy; 2026 <a href=https://rosefinch-midsummer.github.io/zh/>天漢帝國復興錄</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span><div class=busuanzi-footer><span id=busuanzi_container_site_pv>本站总访问量<span id=busuanzi_value_site_pv></span>次
</span><span id=busuanzi_container_site_uv>本站访客数<span id=busuanzi_value_site_uv></span>人次</span></div></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="複製";function s(){t.innerHTML="已複製！",setTimeout(()=>{t.innerHTML="複製"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>