<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>《量子图像处理及其关键技术》 | 天漢帝國復興錄</title><meta name=keywords content="量子计算,图像处理"><meta name=description content="概论
前言
严格来说，我没有读懂这本书，因为我只懂得量子计算的皮毛。
书籍简介

作　者：	马鸿洋 邱田会 王淑梅 田艳兵 史鹏
出版社：	人民邮电出版社
ISBN：	9787115633941
出版时间：	2024-08-01
内容简介
本书系统阐述了量子图像处理及其关键技术。本书内容共分9章，分别介绍了量子图像处理的研究意义和背景与现状、量子图像表示模型、量子图像处理算法、量子图像恢复、量子图像加密、量子水印、量子图像边缘检测、量子图像的分类识别、量子图像仿真实现。本书旨在为量子图像处理领域的科研人员提供具有较强实用性的参考，可作为物理和计算机专业开设量子计算相关课程的教学参考书，也可作为量子计算与量子图像处理的短期专题讲座培训用书。本书结构清晰、内容翔实，对初次接触量子图像处理领域的研究人员，特别是非物理专业的科研技术人员具有一定的参考价值。"><meta name=author content="RM"><link rel=canonical href=https://rosefinch-midsummer.github.io/zh/posts/book/%E9%87%8F%E5%AD%90%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%8F%8A%E5%85%B6%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF/><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><meta name=referrer content="no-referrer-when-downgrade"><link crossorigin=anonymous href=/assets/css/stylesheet.2211ca3164be7830024f6aad2b3a2e520843a64f8f048445c3401c1249aa051d.css integrity="sha256-IhHKMWS+eDACT2qtKzouUghDpk+PBIRFw0AcEkmqBR0=" rel="preload stylesheet" as=style><link rel=icon href=https://rosefinch-midsummer.github.io/img/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://rosefinch-midsummer.github.io/img/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://rosefinch-midsummer.github.io/img/favicon-32x32.png><link rel=apple-touch-icon href=https://rosefinch-midsummer.github.io/img/apple-touch-icon.png><link rel=mask-icon href=https://rosefinch-midsummer.github.io/img/android-chrome-192x192.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://rosefinch-midsummer.github.io/zh/posts/book/%E9%87%8F%E5%AD%90%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%8F%8A%E5%85%B6%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><meta property="og:url" content="https://rosefinch-midsummer.github.io/zh/posts/book/%E9%87%8F%E5%AD%90%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%8F%8A%E5%85%B6%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF/"><meta property="og:site_name" content="天漢帝國復興錄"><meta property="og:title" content="《量子图像处理及其关键技术》"><meta property="og:description" content="概论 前言 严格来说，我没有读懂这本书，因为我只懂得量子计算的皮毛。
书籍简介 作　者：	马鸿洋 邱田会 王淑梅 田艳兵 史鹏
出版社：	人民邮电出版社
ISBN：	9787115633941
出版时间：	2024-08-01
内容简介 本书系统阐述了量子图像处理及其关键技术。本书内容共分9章，分别介绍了量子图像处理的研究意义和背景与现状、量子图像表示模型、量子图像处理算法、量子图像恢复、量子图像加密、量子水印、量子图像边缘检测、量子图像的分类识别、量子图像仿真实现。本书旨在为量子图像处理领域的科研人员提供具有较强实用性的参考，可作为物理和计算机专业开设量子计算相关课程的教学参考书，也可作为量子计算与量子图像处理的短期专题讲座培训用书。本书结构清晰、内容翔实，对初次接触量子图像处理领域的研究人员，特别是非物理专业的科研技术人员具有一定的参考价值。"><meta property="og:locale" content="zh-cn#en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2026-01-13T18:34:25+08:00"><meta property="article:modified_time" content="2026-01-13T22:54:22+08:00"><meta property="article:tag" content="量子计算"><meta property="article:tag" content="图像处理"><meta name=twitter:card content="summary"><meta name=twitter:title content="《量子图像处理及其关键技术》"><meta name=twitter:description content="概论
前言
严格来说，我没有读懂这本书，因为我只懂得量子计算的皮毛。
书籍简介

作　者：	马鸿洋 邱田会 王淑梅 田艳兵 史鹏
出版社：	人民邮电出版社
ISBN：	9787115633941
出版时间：	2024-08-01
内容简介
本书系统阐述了量子图像处理及其关键技术。本书内容共分9章，分别介绍了量子图像处理的研究意义和背景与现状、量子图像表示模型、量子图像处理算法、量子图像恢复、量子图像加密、量子水印、量子图像边缘检测、量子图像的分类识别、量子图像仿真实现。本书旨在为量子图像处理领域的科研人员提供具有较强实用性的参考，可作为物理和计算机专业开设量子计算相关课程的教学参考书，也可作为量子计算与量子图像处理的短期专题讲座培训用书。本书结构清晰、内容翔实，对初次接触量子图像处理领域的研究人员，特别是非物理专业的科研技术人员具有一定的参考价值。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"📚文章","item":"https://rosefinch-midsummer.github.io/zh/posts/"},{"@type":"ListItem","position":2,"name":"📕閱讀","item":"https://rosefinch-midsummer.github.io/zh/posts/book/"},{"@type":"ListItem","position":3,"name":"《量子图像处理及其关键技术》","item":"https://rosefinch-midsummer.github.io/zh/posts/book/%E9%87%8F%E5%AD%90%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%8F%8A%E5%85%B6%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"《量子图像处理及其关键技术》","name":"《量子图像处理及其关键技术》","description":"概论 前言 严格来说，我没有读懂这本书，因为我只懂得量子计算的皮毛。\n书籍简介 作　者：\t马鸿洋 邱田会 王淑梅 田艳兵 史鹏\n出版社：\t人民邮电出版社\nISBN：\t9787115633941\n出版时间：\t2024-08-01\n内容简介 本书系统阐述了量子图像处理及其关键技术。本书内容共分9章，分别介绍了量子图像处理的研究意义和背景与现状、量子图像表示模型、量子图像处理算法、量子图像恢复、量子图像加密、量子水印、量子图像边缘检测、量子图像的分类识别、量子图像仿真实现。本书旨在为量子图像处理领域的科研人员提供具有较强实用性的参考，可作为物理和计算机专业开设量子计算相关课程的教学参考书，也可作为量子计算与量子图像处理的短期专题讲座培训用书。本书结构清晰、内容翔实，对初次接触量子图像处理领域的研究人员，特别是非物理专业的科研技术人员具有一定的参考价值。\n","keywords":["量子计算","图像处理"],"articleBody":"概论 前言 严格来说，我没有读懂这本书，因为我只懂得量子计算的皮毛。\n书籍简介 作　者：\t马鸿洋 邱田会 王淑梅 田艳兵 史鹏\n出版社：\t人民邮电出版社\nISBN：\t9787115633941\n出版时间：\t2024-08-01\n内容简介 本书系统阐述了量子图像处理及其关键技术。本书内容共分9章，分别介绍了量子图像处理的研究意义和背景与现状、量子图像表示模型、量子图像处理算法、量子图像恢复、量子图像加密、量子水印、量子图像边缘检测、量子图像的分类识别、量子图像仿真实现。本书旨在为量子图像处理领域的科研人员提供具有较强实用性的参考，可作为物理和计算机专业开设量子计算相关课程的教学参考书，也可作为量子计算与量子图像处理的短期专题讲座培训用书。本书结构清晰、内容翔实，对初次接触量子图像处理领域的研究人员，特别是非物理专业的科研技术人员具有一定的参考价值。\n作者简介 马鸿洋，2019—2022年山东省物理学类专业及大学物理课程教学指导委员会委员；2018至今教育 部高等学校物理学类专业教学指导委员会华东地区工作委员会委员、量子密码委员会委员、中国电子学信息论分委会委员、大数据与智能信息处理技术委员会委员、山东省物理学会理事会理事、山东省光学工程学会理事、青岛市物理学会理事会理事。 主要研究方向为网络空间安 全、量子保密通信、量子计算、机器学习和深度学习。完成教学科研课题一项，获青岛理工大学优 秀科研成果三等奖一项。\n邱田会，青岛理工大学副教授。主要研究方向为量子光学和量子信息。主持国家自然科学基金青年基金和理论物理专款各一项，主持山东省自然科学基金培养基金项目一项， 作为项目组主要成员参与国家和省部级项目6项。在光的可逆存储、原子相干调控、电磁诱导周期介质性质和应用等方面发表SCI论文20余篇。\n正文摘录 第1章 绪论 1.1 量子图像处理的研究意义 1.2 量子图像处理的背景与现状 参考文献 第2章 量子图像表示模型 2.1 量子图像表示模型及其特点 2.1.1 Qubit Lattice模型 2.1.2 Real Ket模型 2.1.3 Entangled Image模型 2.1.4 FRQI模型 2.1.5 NEQR模型 2.1.6 GQIR模型 2.1.7 NAQSS模型 2.1.8 QRCI模型 2.1.9 QIRHSI模型 2.2 量子图像表示模型分类 2.2.1 量子图像颜色模型 按照颜色信息不同可分为以下几种：\n基于二进制的量子图像表示模型 基于灰度 基于RGB 基于红外图像 2.2.2 量子图像坐标模型 利用不同的坐标系捕捉图像信息：\n基于笛卡尔坐标系的量子图像表示模型 基于对数极坐标系 基于多维表示 2.3 本章小结 参考文献 第3章 量子图像处理算法 3.1 几何变换 本节介绍了基于n个量子比特的标准任意叠加态（NASS）实现图像几何变换。\n3.1.1 两点交换 3.1.2 对称翻转 3.1.3 局部翻转 3.1.4 正交旋转 3.2 色彩处理 3.2.1 量子图像的颜色运算 NEQR模型可以方便地处理图像的颜色信息。\n3.2.2 伪彩色处理 3.2.3 量子色图 3.2.4 量子伪彩色编码实现 3.3 图像分割 3.3.1 基于量子搜索的图像分割 3.3.2 量子图像分割线路 3.3.3 分割后量子图像的显示 3.4 本章小结 参考文献 第4章 量子图像恢复 4.1 量子图像去噪算法 4.1.1 基于NEQR模型的去噪算法 本节主要考虑两种常见噪声，即椒盐噪声和高斯噪声。\n本节主要介绍三张图像去噪算法：\nQ均值滤波算法：采用均值滤波方法处理椒盐噪声 Q高斯滤波算法：主要用于滤除高斯噪声 Q自适应滤波算法：主要用于处理含有未知噪声的图像 4.1.2 基于量子小波变换的图像去噪方法 Daubechies四阶小波核\nCooley-Tukey FFT\n4.2 量子图像复原算法 4.2.1 基于R-L算法的量子图像复原算法 4.2.2 基于约束的最小二乘法滤波的量子图像复原算法 4.3 本章小结 参考文献 第5章 量子图像加密 5.1 图像置乱算法 5.1.1 量子仿射变换 量子仿射变换中应用较广泛的是阿诺德变换和斐波那契变换。利用阿诺德变换和斐波那契变换能够将一幅图像置乱，从而使一幅有意义的图像变成一幅毫无意义的图像。\n5.1.2 量子Hilbert变换 Hilbert曲线是一种连续的参数曲线，类似于Z曲线、格雷码等。\n5.1.3 量子随机行走 马尔可夫过程\n5.1.4 骑士巡游变换 模拟骑士在棋盘中的巡游\n5.2 图像加密算法 5.2.1 离散余弦变换 5.2.2 DNA编码 5.2.3 混沌映射 Rossler混沌模型 Lorenz混沌模型 5.2.4 量子受控翻转 5.3 量子图像加密方案设计 5.3.1 基于交替量子随机行走和离散余弦变换的图像加解密方案 5.3.2 基于DNA编码与交替量子随机行走的图像加密方案 5.3.3 基于量子随机行走和多维混沌映射的图像加密方案 流程包括以下几个步骤：\n图像分割（使用高斯金字塔） 概率矩阵的生成和转化 阿诺德变换置乱 利用欧氏距离和汉明距离求序列 密钥生成 盲水印的嵌入和提取 5.3.4 基于量子受控翻转的图像加密方案 NCQI模型是NEQR模型的改进版\n5.4 本章小结 参考文献 第6章 量子水印 图像信息隐藏的两大手段包括图像加密和数字水印。\n可用于传递秘密信息和版权保护等领域。\n6.1 量子信息隐藏 6.1.1 量子LSB算法 6.1.2 量子傅里叶变换 6.1.3 量子小波变换 6.2 量子水印算法 6.2.1 基于量子LSB分块的水印算法 6.2.2 基于量子傅里叶变换的量子水印算法 6.2.3 基于量子Haar小波变换的水印算法 6.2.4 基于莫尔条纹的量子信息隐藏 6.3 本章小结 参考文献 第7章 量子图像边缘检测 7.1 图像边缘检测技术 7.1.1 Sobel算子图像边缘检测 7.1.2 Prewitt算子图像边缘检测 7.1.3 Kirsch算子图像边缘检测 7.1.4 Canny算子图像边缘检测 7.2 基于Kirsch算子的量子图像边缘检测算法 7.2.1 算法流程 7.2.2 算法复杂度和仿真结果分析 7.3 基于改进Sobel算子的量子图像边缘检测算法 7.3.1 量子线路设计 7.3.2 算法流程 7.3.3 算法实现 7.3.4 仿真结果与分析 7.4 本章小结 参考文献 第8章 量子图像的分类识别 8.1 量子神经网络 8.2 量子卷积神经网络 8.3 基于量子卷积神经网络的手写数字识别 8.3.1 混合量子经典卷积神经网络模型 8.3.2 量子卷积神经网络模型 8.4 本章小结 参考文献 第9章 量子图像仿真实现 根据不同的后端处理系统，量子软件开发工具分为两大类：一类是可以访问量子处理器的SDK，另一类是基于量子计算模拟器的SDK。\n由于量子图像多来自经典世界，需要将经典图像编码为量子信息后再进行处理，而目前尚无可有效完成此项工作的量子计算机，因此量子图像需要通过基于量子计算模拟器的SDK来进行仿真实现。\n9.1 主流量子仿真SDK介绍 Qiskit QPanda Azure Quantum（Q#） 9.2 FRQI和NEQR量子图像的仿真 9.2.1 制备FRQI图像量子态 9.2.2 四像素灰度FRQI图像仿真实现 9.2.3 制备NEQR量子态 9.2.4 四像素灰度NEQR图像仿真实现 9.3 小图像和大图像的量子边缘检测QHED算法 9.3.1 量子概率图像编码 9.3.2 量子Hadamard边缘检测 9.4 本章小结 参考文献 附录 量子计算编程入门内容总结-Qiskit 1. 基础知识与前言 除了理论内容之外，在量子SDK (Quantum Software Development Kit) 上对于程序和算法的实现同样重要，本文将以之前文章的内容为基础探索Qiskit的使用方法：\nMercury：量子计算入门内容总结501 赞同 · 14 评论 文章\n同样，在开始正式学习Qiskit之前，我们需要一些基本的计算机知识，熟悉的同学可以直接跳过这个章节，这里我们主要是基于Python来编程。\n1.1. 在官网上下载Python和Qiskit开发工具包 笔者主要使用的是Anaconda Python，可以在官网上直接下载；之后在terminal中输入 (笔者使用的是macOS系统) 来下载Qiskit开发工具包：\n1 pip install qiskit 之后我们可以在terminal中通过输入如下的代码跳转到Jupyter Notebook的页面，Jupyter Notebook可能是结合编程、文本和图像的最佳方式：\n1 jupyter notebook 在Jupyter Notebook创建一个新文件之后输入如下的代码我们便可以检验是否下载好并且是否下载了最新的版本：\n1 2 import qiskit qiskit.__qiskit_version__ 这里我的输出结果为如下所示，说明我的版本为0.45.0，在Qiskit官网上可以发现是截止这篇文章发布前的最新版。\n1 {'qiskit': '0.45.0', 'qiskit-aer': '0.13.0', 'qiskit-ignis': None, 'qiskit-ibmq-provider': '0.20.2', 'qiskit-nature': None, 'qiskit-finance': None, 'qiskit-optimization': None, 'qiskit-machine-learning': None} 之后我们需要在IBM的官网上注册账号来获取API代码，这是我们和IBM的量子计算机链接的途径，在个人主页中找到后复制到如下的代码中，我们就可以把我们在自己电脑上创建的量子电路传输给IBM的量子计算机并得到结果。\n1 2 3 from qiskit import IBMQ IBMQ.save_account('在这里输入你的API代码') IBMQ.load_account() 1.2. Python基础知识 这里的内容不是本文的重点，以下的内容默认读者对Python中的基础语法有所掌握。\n1.3. 量子计算基础知识 在之前的内容中，我们学习了使用态叠加原理来表示一个量子比特的状态，即用以 和 为基向量的线性组合 来表示，那么我们如何在Qiskit开发工具包中表示这个状态呢？首先我们引入我们需要使用的工具：\n1 2 3 from qiskit import QuantumCircuit, assemble, Aer from qiskit.visualization import plot_histogram, plot_bloch_vector from math import sqrt, pi 其次我们建立一个单量子比特的电路，通过之前的学习我们知道一个量子比特总是以 开始的，在Qiskit中我们可以使用initialize()将它转化成任何状态。比如在这里我们将 输入进去，并告诉它哪一个量子比特是我们想初始化的：\n1 2 3 4 qc = QuantumCircuit(1) # 建立一个单量子比特电路 initial_state = [0,1] # 定义初始状态 |1\u003e qc.initialize(initial_state, 0) # 对第0个量子比特应用初始化的操作 qc.draw() # 通过这条指令可以展示我们设置的量子电路 之后我们可以使用Qiskit的模拟器来查看量子比特的最终状态，为了从电路中获得结果，我们使用run来执行电路，最后我们可以通过.result()来获得结果。\n1 2 3 4 5 6 sim = Aer.get_backend('aer_simulator') # 告诉Qiskit如何模拟我们的电路 qc.save_statevector() # 告诉模拟器保存statevector qobj = assemble(qc) # 从电路中创建一个Qobj来给模拟器进行模拟 result = sim.run(qobj).result() # 进行模拟并显示结果 out_state = result.get_statevector() print(out_state) # 用statevector的形式展示最后的结果 我最后得到如下的结果：Python通常通过 来表示复数里的 ，因此我这里得到的 。\n1 2 Statevector([0.+0.j, 1.+0.j], dims=(2,)) 现在让我们像真正的量子计算机那样测量我们的量子比特并观察我们可以得到的结果：\n1 2 qc.measure_all() qc.draw() 我们可以得到这样的图像：\n我们得到的量子电路\n为了和之前得到的statevector结果不一样，我们可以使用.get_counts()来获得测量出0和1的数量：\n1 2 3 4 qobj = assemble(qc) result = sim.run(qobj).result() counts = result.get_counts() plot_histogram(counts) 从得到的结果中我们看出，我们100%会测量出 。\n我们得到的测量结果\n接下来如果我们将输入的状态换成叠加态 ，看看会发生什么？\n1 2 3 4 5 6 7 initial_state = [1/sqrt(2), 1j/sqrt(2)] # 定义状态 |q_0\u003e qc = QuantumCircuit(1) # 我们必须重新定义qc qc.initialize(initial_state, 0) # 对第0个量子比特应用初始化的操作 qc.save_statevector() # 保存statevector qobj = assemble(qc) state = sim.run(qobj).result().get_statevector() # 执行电路 print(state) # 输出结果 之后我们可以得到如下的结果，并重复以上的操作，我们可以得到测量的结果，即我们有50%的几率测量出 ，也有50%的几率测量出 。\n1 2 3 qobj = assemble(qc) results = sim.run(qobj).result().get_counts() plot_histogram(results) 我们得到的测量结果\n在之前我们同样也学习了布洛赫球(Bloch sphere) 的表达形式，那么我们怎么使用Qiskit来形象的表示布洛赫球呢？首先我们需要通过如下的代码安装’qiskit_textbook’模块：\n1 pip install git+https://github.com/qiskit-community/qiskit-textbook.git#subdirectory=qiskit-textbook-src 之后我们再使用如下的代码就可以表示布洛赫球了，这里我们定义 (注意这里可能需要根据情况从math中引入pi或者从numpy库中导入)：\n1 2 3 from qiskit_textbook.widgets import plot_bloch_vector_spherical coords = [pi/2,0,1] # 输入[Theta, Phi, Radius] plot_bloch_vector_spherical(coords) # 布洛赫向量 我们可以得到如下的结果：\n我们得到的结果\n除了对量子比特的描述之外，我们在之前的内容里也了解了很多有关单比特量子门的内容，我们下面就具体看一下如何在Qiskit中表示量子门，首先是最常见的 门， 门和 门，我们可以用如下的形式来表示：\n1 2 3 qc = QuantumCircuit(1) # 首先我们先创建一个单量子比特电路 qc.x(0) # 在第0个量子比特上放上X门 qc.draw() # 画出我们设计的电路 我们可以得到：\n我们得到的结果\n类似的，我们可以在同样的一条电路上放上 门和 门：\n1 2 3 4 5 from qiskit_textbook.widgets import gate_demo gate_demo(gates='pauli') qc.y(0) # 在第0个量子比特上放上Y门 qc.z(0) # 在第0个量子比特上放上Z门 qc.draw() 我们可以得到：\n我们得到的结果\n类似的，我们接着引入 门和 门：\n1 2 from qiskit_textbook.widgets import gate_demo gate_demo(gates='pauli+h+p') 在Qiskit中，我们通常通过两个变量来描述 门：\n1 2 3 qc = QuantumCircuit(1) qc.p(pi/4, 0) # 前面一个数字用来表示phi，后面一个数字来表示需要操作的量子比特 qc.draw() 我们可以得到：\n我们得到的结果\n以上就是一些常用的量子系统的状态和量子门的表达方式，这里的内容肯定不是足够详尽的，如果在实际使用中遇到了不常见的情况，我们可以通过登陆Qiskit或者IBM的官网进行查询。\n2. 从传统算法到量子算法 2.1. Deutsch-Jozsa算法 在之前的内容中，我们介绍了D-J算法的使用场景和主要结构，D-J算法为了解决判断输入的函数 为常函数还是平衡函数而诞生。那么如果我们想要在Qiskit中运行，我们应该怎么做呢？在本文的例子中，我们针对以下函数进行算法的撰写，具体算法是怎么写出来的，不是本文的重点内容，这里我们重点关注如何在Qiskit中实现：\n第一步我们要初始化所有的量子比特以满足D-J算法的需求：\n1 2 3 4 5 6 7 8 9 10 dj_circuit = QuantumCircuit(n+1, n) # 应用H门 for qubit in range(n): dj_circuit.h(qubit) # 将最底部的量子比特转化成 |-\u003e dj_circuit.x(n) dj_circuit.h(n) dj_circuit.draw() 第二步我们要加上预言机里的量子门：\n1 2 3 4 5 6 7 8 9 10 11 12 13 dj_circuit = QuantumCircuit(n+1, n) # 应用H门 for qubit in range(n): dj_circuit.h(qubit) # 将最底部的量子比特转化成 |-\u003e dj_circuit.x(n) dj_circuit.h(n) # 增加预言机里的量子门 dj_circuit = dj_circuit.compose(balanced_oracle) dj_circuit.draw() 最后我们要根据算法的结构在n个量子比特上加入 门，并测量所有输入的量子寄存器：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 dj_circuit = QuantumCircuit(n+1, n) # 应用H门 for qubit in range(n): dj_circuit.h(qubit) # 将最底部的量子比特转化成 |-\u003e dj_circuit.x(n) dj_circuit.h(n) # 增加预言机里的量子门 dj_circuit = dj_circuit.compose(balanced_oracle) # 重复H门 for qubit in range(n): dj_circuit.h(qubit) dj_circuit.barrier() # 测量 for i in range(n): dj_circuit.measure(i, i) # 表示电路 dj_circuit.draw() 于是我们可以得到：\nD-J算法\n如果我们想得到测量的结果，我们可以重复上面学习过的使用量子模拟器的方法：\n1 2 3 4 5 aer_sim = Aer.get_backend('aer_simulator') results = aer_sim.run(dj_circuit).result() answer = results.get_counts() plot_histogram(answer) 我们可以得到结果：\n我们得到的结果\n根据我们之前学习的内容，如果所有量子比特的测量结果都为0，那么这个函数就可以判断为常函数；如果我们得到任何0之外的结果，那么这个函数就可以判断为平衡函数。从我们得到的结果我们可以很明显看出这个函数为平衡函数。\n2.2. Simon算法 在之前的学习中我们了解了Simon算法的使用场景和基本结构，那么我们怎么在Qiskit中实现Simon算法呢？我们这里可以直接通过simon_oracle创造一个Simon算法的预言机，在这里的例子里，我们假设 。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 # 引入Qiskit的各类工具 from qiskit import IBMQ, Aer from qiskit.providers.ibmq import least_busy from qiskit import QuantumCircuit, transpile from qiskit.visualization import plot_histogram from qiskit_textbook.tools import simon_oracle b = '110' n = len(b) simon_circuit = QuantumCircuit(n*2, n) # 根据Simon算法的结构应用H门 simon_circuit.h(range(n)) # 在这里增加barrier以区分不同区域 simon_circuit.barrier() # 这里我们直接通过simon_oracle创造一个simon算法的预言机 simon_circuit = simon_circuit.compose(simon_oracle(b)) # 在这里增加barrier以区分不同的区域 simon_circuit.barrier() # 根据Simon算法的结构应用H门 simon_circuit.h(range(n)) # 测量量子比特 simon_circuit.measure(range(n), range(n)) simon_circuit.draw() 我们在这里得到的结果为：\n我们在这里得到的结果\n类似的，我们可以通过使用量子模拟器来得到测量的结果：\n1 2 3 4 aer_sim = Aer.get_backend('aer_simulator') results = aer_sim.run(simon_circuit).result() counts = results.get_counts() plot_histogram(counts) 于是我们可以得到如下的结果，之后我们再应用传统算法就可以得到最后的结果：\n在之前的内容中，我们同样引入了Shor算法、Grover算法和QAOA算法，由于这几个算法涉及量子傅里叶变换 (Quantum Fourier Transform)和QPE算法 (Quantum Phase Estimation)，我之后会针对这个内容做一个专题进行解释和总结。\n3. 量子计算在密码学中的应用 3.1. 量子密钥分发 (QKD) 我们在之前的内容中介绍了量子密钥分发的原理，即如果Alice希望发送给Bob一个量子比特，但窃听者试图在Bob之前测量这个量子比特，那么窃听者的测量有可能改变量子比特的状态，而Bob将接收不到Alice发送的量子比特的状态。假设Alice希望用x基来表示 ，并将其发给Bob，如果Bob同样用x基来进行解密，那么他一定会得到 ，在Qiskit我们这样表示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from qiskit import QuantumCircuit, Aer, transpile from qiskit.visualization import plot_histogram, plot_bloch_multivector from numpy.random import randint import numpy as np qc = QuantumCircuit(1,1) # Alice 将量子比特转换成|+\u003e来发送 qc.h(0) qc.barrier() # Alice 现在把这个量子比特发送给Bob # Bob 使用相同的基来进行测量 qc.h(0) qc.measure(0,0) # 画出并模拟电路 display(qc.draw()) aer_sim = Aer.get_backend('aer_simulator') job = aer_sim.run(qc) plot_histogram(job.result().get_counts()) 我们可以得到：\n我们得到的结果\n通过之前的学习我们知道，如果窃听者在Bob之前尝试通过z基测量，那么Bob就不会一定得到 。在Qiskit中我们这样表示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 qc = QuantumCircuit(1,1) # Alice 将量子比特转换成|+\u003e来发送 qc.h(0) # Alice 现在把这个量子比特发送给Bob # 但是窃听者尝试阅读这个消息 qc.measure(0, 0) qc.barrier() # 窃听者在解密后将结果传达给Bob # Bob用x基来进行解密 qc.h(0) qc.measure(0,0) # 画出并模拟电路 display(qc.draw()) aer_sim = Aer.get_backend('aer_simulator') job = aer_sim.run(qc) plot_histogram(job.result().get_counts()) 我们可以得到如下的结果：\n我们得到的结果\n从结果中我们可以观察到，Bob测量出 的概率仅剩50%左右。\n4. 量子机器学习 由于篇幅限制，之后我会针对量子机器学习的内容做一个专题进行解释和总结。\n声明：本文的主要内容为针对Qiskit中提供的教程进行的总结\n","wordCount":"6556","inLanguage":"zh","datePublished":"2026-01-13T18:34:25+08:00","dateModified":"2026-01-13T22:54:22+08:00","author":{"@type":"Person","name":"RM"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://rosefinch-midsummer.github.io/zh/posts/book/%E9%87%8F%E5%AD%90%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%8F%8A%E5%85%B6%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF/"},"publisher":{"@type":"Organization","name":"天漢帝國復興錄","logo":{"@type":"ImageObject","url":"https://rosefinch-midsummer.github.io/img/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://rosefinch-midsummer.github.io/zh/ accesskey=h title="天漢帝國復興錄 (Alt + H)">天漢帝國復興錄</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://rosefinch-midsummer.github.io/zh/ title=🏠主頁><span>🏠主頁</span></a></li><li><a href=https://rosefinch-midsummer.github.io/zh/posts title=📚文章><span>📚文章</span></a></li><li><a href=https://rosefinch-midsummer.github.io/zh/search title="🔍搜索 (Alt + /)" accesskey=/><span>🔍搜索</span></a></li><li><a href=https://rosefinch-midsummer.github.io/zh/archives title=⏱時間軸><span>⏱時間軸</span></a></li><li><a href=https://rosefinch-midsummer.github.io/zh/categories title=🧩分類><span>🧩分類</span></a></li><li><a href=https://rosefinch-midsummer.github.io/zh/tags title=🔖標簽><span>🔖標簽</span></a></li><li><a href=https://rosefinch-midsummer.github.io/zh/about title=🙋🏻‍♂️關于><span>🙋🏻‍♂️關于</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://rosefinch-midsummer.github.io/zh/>首頁</a>&nbsp;»&nbsp;<a href=https://rosefinch-midsummer.github.io/zh/posts/>📚文章</a>&nbsp;»&nbsp;<a href=https://rosefinch-midsummer.github.io/zh/posts/book/>📕閱讀</a></div><h1 class=post-title>《量子图像处理及其关键技术》</h1><div class=post-meta>创建: 2026-01-13 |
更新: 2026-01-13 |
字数: 6556字 |
时长: 14分钟 |
RM</div><div class=meta-item>&nbsp·&nbsp
<span id=busuanzi_container_page_pv>本文阅读量<span id=busuanzi_value_page_pv></span>次</span></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目錄</span></summary><div class=inner><ul><li><a href=#%e6%a6%82%e8%ae%ba aria-label=概论>概论</a><ul><li><a href=#%e5%89%8d%e8%a8%80 aria-label=前言>前言</a></li><li><a href=#%e4%b9%a6%e7%b1%8d%e7%ae%80%e4%bb%8b aria-label=书籍简介>书籍简介</a></li><li><a href=#%e5%86%85%e5%ae%b9%e7%ae%80%e4%bb%8b aria-label=内容简介>内容简介</a></li><li><a href=#%e4%bd%9c%e8%80%85%e7%ae%80%e4%bb%8b aria-label=作者简介>作者简介</a></li></ul></li><li><a href=#%e6%ad%a3%e6%96%87%e6%91%98%e5%bd%95 aria-label=正文摘录>正文摘录</a><ul><li><a href=#%e7%ac%ac1%e7%ab%a0-%e7%bb%aa%e8%ae%ba aria-label="第1章 绪论">第1章 绪论</a><ul><li><a href=#11-%e9%87%8f%e5%ad%90%e5%9b%be%e5%83%8f%e5%a4%84%e7%90%86%e7%9a%84%e7%a0%94%e7%a9%b6%e6%84%8f%e4%b9%89 aria-label="1.1 量子图像处理的研究意义">1.1 量子图像处理的研究意义</a></li><li><a href=#12-%e9%87%8f%e5%ad%90%e5%9b%be%e5%83%8f%e5%a4%84%e7%90%86%e7%9a%84%e8%83%8c%e6%99%af%e4%b8%8e%e7%8e%b0%e7%8a%b6 aria-label="1.2 量子图像处理的背景与现状">1.2 量子图像处理的背景与现状</a></li><li><a href=#%e5%8f%82%e8%80%83%e6%96%87%e7%8c%ae aria-label=参考文献>参考文献</a></li></ul></li><li><a href=#%e7%ac%ac2%e7%ab%a0-%e9%87%8f%e5%ad%90%e5%9b%be%e5%83%8f%e8%a1%a8%e7%a4%ba%e6%a8%a1%e5%9e%8b aria-label="第2章 量子图像表示模型">第2章 量子图像表示模型</a><ul><li><a href=#21-%e9%87%8f%e5%ad%90%e5%9b%be%e5%83%8f%e8%a1%a8%e7%a4%ba%e6%a8%a1%e5%9e%8b%e5%8f%8a%e5%85%b6%e7%89%b9%e7%82%b9 aria-label="2.1 量子图像表示模型及其特点">2.1 量子图像表示模型及其特点</a><ul><li><a href=#211-qubit-lattice%e6%a8%a1%e5%9e%8b aria-label="2.1.1 Qubit Lattice模型">2.1.1 Qubit Lattice模型</a></li><li><a href=#212-real-ket%e6%a8%a1%e5%9e%8b aria-label="2.1.2 Real Ket模型">2.1.2 Real Ket模型</a></li><li><a href=#213-entangled-image%e6%a8%a1%e5%9e%8b aria-label="2.1.3 Entangled Image模型">2.1.3 Entangled Image模型</a></li><li><a href=#214-frqi%e6%a8%a1%e5%9e%8b aria-label="2.1.4 FRQI模型">2.1.4 FRQI模型</a></li><li><a href=#215-neqr%e6%a8%a1%e5%9e%8b aria-label="2.1.5 NEQR模型">2.1.5 NEQR模型</a></li><li><a href=#216-gqir%e6%a8%a1%e5%9e%8b aria-label="2.1.6 GQIR模型">2.1.6 GQIR模型</a></li><li><a href=#217-naqss%e6%a8%a1%e5%9e%8b aria-label="2.1.7 NAQSS模型">2.1.7 NAQSS模型</a></li><li><a href=#218-qrci%e6%a8%a1%e5%9e%8b aria-label="2.1.8 QRCI模型">2.1.8 QRCI模型</a></li><li><a href=#219-qirhsi%e6%a8%a1%e5%9e%8b aria-label="2.1.9 QIRHSI模型">2.1.9 QIRHSI模型</a></li></ul></li><li><a href=#22-%e9%87%8f%e5%ad%90%e5%9b%be%e5%83%8f%e8%a1%a8%e7%a4%ba%e6%a8%a1%e5%9e%8b%e5%88%86%e7%b1%bb aria-label="2.2 量子图像表示模型分类">2.2 量子图像表示模型分类</a><ul><li><a href=#221-%e9%87%8f%e5%ad%90%e5%9b%be%e5%83%8f%e9%a2%9c%e8%89%b2%e6%a8%a1%e5%9e%8b aria-label="2.2.1 量子图像颜色模型">2.2.1 量子图像颜色模型</a></li><li><a href=#222-%e9%87%8f%e5%ad%90%e5%9b%be%e5%83%8f%e5%9d%90%e6%a0%87%e6%a8%a1%e5%9e%8b aria-label="2.2.2 量子图像坐标模型">2.2.2 量子图像坐标模型</a></li></ul></li><li><a href=#23-%e6%9c%ac%e7%ab%a0%e5%b0%8f%e7%bb%93 aria-label="2.3 本章小结">2.3 本章小结</a></li><li><a href=#%e5%8f%82%e8%80%83%e6%96%87%e7%8c%ae-1 aria-label=参考文献>参考文献</a></li></ul></li><li><a href=#%e7%ac%ac3%e7%ab%a0-%e9%87%8f%e5%ad%90%e5%9b%be%e5%83%8f%e5%a4%84%e7%90%86%e7%ae%97%e6%b3%95 aria-label="第3章 量子图像处理算法">第3章 量子图像处理算法</a><ul><li><a href=#31-%e5%87%a0%e4%bd%95%e5%8f%98%e6%8d%a2 aria-label="3.1 几何变换">3.1 几何变换</a><ul><li><a href=#311-%e4%b8%a4%e7%82%b9%e4%ba%a4%e6%8d%a2 aria-label="3.1.1 两点交换">3.1.1 两点交换</a></li><li><a href=#312-%e5%af%b9%e7%a7%b0%e7%bf%bb%e8%bd%ac aria-label="3.1.2 对称翻转">3.1.2 对称翻转</a></li><li><a href=#313-%e5%b1%80%e9%83%a8%e7%bf%bb%e8%bd%ac aria-label="3.1.3 局部翻转">3.1.3 局部翻转</a></li><li><a href=#314-%e6%ad%a3%e4%ba%a4%e6%97%8b%e8%bd%ac aria-label="3.1.4 正交旋转">3.1.4 正交旋转</a></li></ul></li><li><a href=#32-%e8%89%b2%e5%bd%a9%e5%a4%84%e7%90%86 aria-label="3.2 色彩处理">3.2 色彩处理</a><ul><li><a href=#321-%e9%87%8f%e5%ad%90%e5%9b%be%e5%83%8f%e7%9a%84%e9%a2%9c%e8%89%b2%e8%bf%90%e7%ae%97 aria-label="3.2.1 量子图像的颜色运算">3.2.1 量子图像的颜色运算</a></li><li><a href=#322-%e4%bc%aa%e5%bd%a9%e8%89%b2%e5%a4%84%e7%90%86 aria-label="3.2.2 伪彩色处理">3.2.2 伪彩色处理</a></li><li><a href=#323-%e9%87%8f%e5%ad%90%e8%89%b2%e5%9b%be aria-label="3.2.3 量子色图">3.2.3 量子色图</a></li><li><a href=#324-%e9%87%8f%e5%ad%90%e4%bc%aa%e5%bd%a9%e8%89%b2%e7%bc%96%e7%a0%81%e5%ae%9e%e7%8e%b0 aria-label="3.2.4 量子伪彩色编码实现">3.2.4 量子伪彩色编码实现</a></li></ul></li><li><a href=#33-%e5%9b%be%e5%83%8f%e5%88%86%e5%89%b2 aria-label="3.3 图像分割">3.3 图像分割</a><ul><li><a href=#331-%e5%9f%ba%e4%ba%8e%e9%87%8f%e5%ad%90%e6%90%9c%e7%b4%a2%e7%9a%84%e5%9b%be%e5%83%8f%e5%88%86%e5%89%b2 aria-label="3.3.1 基于量子搜索的图像分割">3.3.1 基于量子搜索的图像分割</a></li><li><a href=#332-%e9%87%8f%e5%ad%90%e5%9b%be%e5%83%8f%e5%88%86%e5%89%b2%e7%ba%bf%e8%b7%af aria-label="3.3.2 量子图像分割线路">3.3.2 量子图像分割线路</a></li><li><a href=#333-%e5%88%86%e5%89%b2%e5%90%8e%e9%87%8f%e5%ad%90%e5%9b%be%e5%83%8f%e7%9a%84%e6%98%be%e7%a4%ba aria-label="3.3.3 分割后量子图像的显示">3.3.3 分割后量子图像的显示</a></li></ul></li><li><a href=#34-%e6%9c%ac%e7%ab%a0%e5%b0%8f%e7%bb%93 aria-label="3.4 本章小结">3.4 本章小结</a></li><li><a href=#%e5%8f%82%e8%80%83%e6%96%87%e7%8c%ae-2 aria-label=参考文献>参考文献</a></li></ul></li><li><a href=#%e7%ac%ac4%e7%ab%a0-%e9%87%8f%e5%ad%90%e5%9b%be%e5%83%8f%e6%81%a2%e5%a4%8d aria-label="第4章 量子图像恢复">第4章 量子图像恢复</a><ul><li><a href=#41-%e9%87%8f%e5%ad%90%e5%9b%be%e5%83%8f%e5%8e%bb%e5%99%aa%e7%ae%97%e6%b3%95 aria-label="4.1 量子图像去噪算法">4.1 量子图像去噪算法</a><ul><li><a href=#411-%e5%9f%ba%e4%ba%8eneqr%e6%a8%a1%e5%9e%8b%e7%9a%84%e5%8e%bb%e5%99%aa%e7%ae%97%e6%b3%95 aria-label="4.1.1 基于NEQR模型的去噪算法">4.1.1 基于NEQR模型的去噪算法</a></li><li><a href=#412-%e5%9f%ba%e4%ba%8e%e9%87%8f%e5%ad%90%e5%b0%8f%e6%b3%a2%e5%8f%98%e6%8d%a2%e7%9a%84%e5%9b%be%e5%83%8f%e5%8e%bb%e5%99%aa%e6%96%b9%e6%b3%95 aria-label="4.1.2 基于量子小波变换的图像去噪方法">4.1.2 基于量子小波变换的图像去噪方法</a></li></ul></li><li><a href=#42-%e9%87%8f%e5%ad%90%e5%9b%be%e5%83%8f%e5%a4%8d%e5%8e%9f%e7%ae%97%e6%b3%95 aria-label="4.2 量子图像复原算法">4.2 量子图像复原算法</a><ul><li><a href=#421-%e5%9f%ba%e4%ba%8er-l%e7%ae%97%e6%b3%95%e7%9a%84%e9%87%8f%e5%ad%90%e5%9b%be%e5%83%8f%e5%a4%8d%e5%8e%9f%e7%ae%97%e6%b3%95 aria-label="4.2.1 基于R-L算法的量子图像复原算法">4.2.1 基于R-L算法的量子图像复原算法</a></li><li><a href=#422-%e5%9f%ba%e4%ba%8e%e7%ba%a6%e6%9d%9f%e7%9a%84%e6%9c%80%e5%b0%8f%e4%ba%8c%e4%b9%98%e6%b3%95%e6%bb%a4%e6%b3%a2%e7%9a%84%e9%87%8f%e5%ad%90%e5%9b%be%e5%83%8f%e5%a4%8d%e5%8e%9f%e7%ae%97%e6%b3%95 aria-label="4.2.2 基于约束的最小二乘法滤波的量子图像复原算法">4.2.2 基于约束的最小二乘法滤波的量子图像复原算法</a></li></ul></li><li><a href=#43-%e6%9c%ac%e7%ab%a0%e5%b0%8f%e7%bb%93 aria-label="4.3 本章小结">4.3 本章小结</a></li><li><a href=#%e5%8f%82%e8%80%83%e6%96%87%e7%8c%ae-3 aria-label=参考文献>参考文献</a></li></ul></li><li><a href=#%e7%ac%ac5%e7%ab%a0-%e9%87%8f%e5%ad%90%e5%9b%be%e5%83%8f%e5%8a%a0%e5%af%86 aria-label="第5章 量子图像加密">第5章 量子图像加密</a><ul><li><a href=#51-%e5%9b%be%e5%83%8f%e7%bd%ae%e4%b9%b1%e7%ae%97%e6%b3%95 aria-label="5.1 图像置乱算法">5.1 图像置乱算法</a><ul><li><a href=#511-%e9%87%8f%e5%ad%90%e4%bb%bf%e5%b0%84%e5%8f%98%e6%8d%a2 aria-label="5.1.1 量子仿射变换">5.1.1 量子仿射变换</a></li><li><a href=#512-%e9%87%8f%e5%ad%90hilbert%e5%8f%98%e6%8d%a2 aria-label="5.1.2 量子Hilbert变换">5.1.2 量子Hilbert变换</a></li><li><a href=#513-%e9%87%8f%e5%ad%90%e9%9a%8f%e6%9c%ba%e8%a1%8c%e8%b5%b0 aria-label="5.1.3 量子随机行走">5.1.3 量子随机行走</a></li><li><a href=#514-%e9%aa%91%e5%a3%ab%e5%b7%a1%e6%b8%b8%e5%8f%98%e6%8d%a2 aria-label="5.1.4 骑士巡游变换">5.1.4 骑士巡游变换</a></li></ul></li><li><a href=#52-%e5%9b%be%e5%83%8f%e5%8a%a0%e5%af%86%e7%ae%97%e6%b3%95 aria-label="5.2 图像加密算法">5.2 图像加密算法</a><ul><li><a href=#521-%e7%a6%bb%e6%95%a3%e4%bd%99%e5%bc%a6%e5%8f%98%e6%8d%a2 aria-label="5.2.1 离散余弦变换">5.2.1 离散余弦变换</a></li><li><a href=#522-dna%e7%bc%96%e7%a0%81 aria-label="5.2.2 DNA编码">5.2.2 DNA编码</a></li><li><a href=#523-%e6%b7%b7%e6%b2%8c%e6%98%a0%e5%b0%84 aria-label="5.2.3 混沌映射">5.2.3 混沌映射</a></li><li><a href=#524-%e9%87%8f%e5%ad%90%e5%8f%97%e6%8e%a7%e7%bf%bb%e8%bd%ac aria-label="5.2.4 量子受控翻转">5.2.4 量子受控翻转</a></li></ul></li><li><a href=#53-%e9%87%8f%e5%ad%90%e5%9b%be%e5%83%8f%e5%8a%a0%e5%af%86%e6%96%b9%e6%a1%88%e8%ae%be%e8%ae%a1 aria-label="5.3 量子图像加密方案设计">5.3 量子图像加密方案设计</a><ul><li><a href=#531-%e5%9f%ba%e4%ba%8e%e4%ba%a4%e6%9b%bf%e9%87%8f%e5%ad%90%e9%9a%8f%e6%9c%ba%e8%a1%8c%e8%b5%b0%e5%92%8c%e7%a6%bb%e6%95%a3%e4%bd%99%e5%bc%a6%e5%8f%98%e6%8d%a2%e7%9a%84%e5%9b%be%e5%83%8f%e5%8a%a0%e8%a7%a3%e5%af%86%e6%96%b9%e6%a1%88 aria-label="5.3.1 基于交替量子随机行走和离散余弦变换的图像加解密方案">5.3.1 基于交替量子随机行走和离散余弦变换的图像加解密方案</a></li><li><a href=#532-%e5%9f%ba%e4%ba%8edna%e7%bc%96%e7%a0%81%e4%b8%8e%e4%ba%a4%e6%9b%bf%e9%87%8f%e5%ad%90%e9%9a%8f%e6%9c%ba%e8%a1%8c%e8%b5%b0%e7%9a%84%e5%9b%be%e5%83%8f%e5%8a%a0%e5%af%86%e6%96%b9%e6%a1%88 aria-label="5.3.2 基于DNA编码与交替量子随机行走的图像加密方案">5.3.2 基于DNA编码与交替量子随机行走的图像加密方案</a></li><li><a href=#533-%e5%9f%ba%e4%ba%8e%e9%87%8f%e5%ad%90%e9%9a%8f%e6%9c%ba%e8%a1%8c%e8%b5%b0%e5%92%8c%e5%a4%9a%e7%bb%b4%e6%b7%b7%e6%b2%8c%e6%98%a0%e5%b0%84%e7%9a%84%e5%9b%be%e5%83%8f%e5%8a%a0%e5%af%86%e6%96%b9%e6%a1%88 aria-label="5.3.3 基于量子随机行走和多维混沌映射的图像加密方案">5.3.3 基于量子随机行走和多维混沌映射的图像加密方案</a></li><li><a href=#534-%e5%9f%ba%e4%ba%8e%e9%87%8f%e5%ad%90%e5%8f%97%e6%8e%a7%e7%bf%bb%e8%bd%ac%e7%9a%84%e5%9b%be%e5%83%8f%e5%8a%a0%e5%af%86%e6%96%b9%e6%a1%88 aria-label="5.3.4 基于量子受控翻转的图像加密方案">5.3.4 基于量子受控翻转的图像加密方案</a></li></ul></li><li><a href=#54-%e6%9c%ac%e7%ab%a0%e5%b0%8f%e7%bb%93 aria-label="5.4 本章小结">5.4 本章小结</a></li><li><a href=#%e5%8f%82%e8%80%83%e6%96%87%e7%8c%ae-4 aria-label=参考文献>参考文献</a></li></ul></li><li><a href=#%e7%ac%ac6%e7%ab%a0-%e9%87%8f%e5%ad%90%e6%b0%b4%e5%8d%b0 aria-label="第6章 量子水印">第6章 量子水印</a><ul><li><a href=#61-%e9%87%8f%e5%ad%90%e4%bf%a1%e6%81%af%e9%9a%90%e8%97%8f aria-label="6.1 量子信息隐藏">6.1 量子信息隐藏</a><ul><li><a href=#611-%e9%87%8f%e5%ad%90lsb%e7%ae%97%e6%b3%95 aria-label="6.1.1 量子LSB算法">6.1.1 量子LSB算法</a></li><li><a href=#612-%e9%87%8f%e5%ad%90%e5%82%85%e9%87%8c%e5%8f%b6%e5%8f%98%e6%8d%a2 aria-label="6.1.2 量子傅里叶变换">6.1.2 量子傅里叶变换</a></li><li><a href=#613-%e9%87%8f%e5%ad%90%e5%b0%8f%e6%b3%a2%e5%8f%98%e6%8d%a2 aria-label="6.1.3 量子小波变换">6.1.3 量子小波变换</a></li></ul></li><li><a href=#62-%e9%87%8f%e5%ad%90%e6%b0%b4%e5%8d%b0%e7%ae%97%e6%b3%95 aria-label="6.2 量子水印算法">6.2 量子水印算法</a><ul><li><a href=#621-%e5%9f%ba%e4%ba%8e%e9%87%8f%e5%ad%90lsb%e5%88%86%e5%9d%97%e7%9a%84%e6%b0%b4%e5%8d%b0%e7%ae%97%e6%b3%95 aria-label="6.2.1 基于量子LSB分块的水印算法">6.2.1 基于量子LSB分块的水印算法</a></li><li><a href=#622-%e5%9f%ba%e4%ba%8e%e9%87%8f%e5%ad%90%e5%82%85%e9%87%8c%e5%8f%b6%e5%8f%98%e6%8d%a2%e7%9a%84%e9%87%8f%e5%ad%90%e6%b0%b4%e5%8d%b0%e7%ae%97%e6%b3%95 aria-label="6.2.2 基于量子傅里叶变换的量子水印算法">6.2.2 基于量子傅里叶变换的量子水印算法</a></li><li><a href=#623-%e5%9f%ba%e4%ba%8e%e9%87%8f%e5%ad%90haar%e5%b0%8f%e6%b3%a2%e5%8f%98%e6%8d%a2%e7%9a%84%e6%b0%b4%e5%8d%b0%e7%ae%97%e6%b3%95 aria-label="6.2.3 基于量子Haar小波变换的水印算法">6.2.3 基于量子Haar小波变换的水印算法</a></li><li><a href=#624-%e5%9f%ba%e4%ba%8e%e8%8e%ab%e5%b0%94%e6%9d%a1%e7%ba%b9%e7%9a%84%e9%87%8f%e5%ad%90%e4%bf%a1%e6%81%af%e9%9a%90%e8%97%8f aria-label="6.2.4 基于莫尔条纹的量子信息隐藏">6.2.4 基于莫尔条纹的量子信息隐藏</a></li></ul></li><li><a href=#63-%e6%9c%ac%e7%ab%a0%e5%b0%8f%e7%bb%93 aria-label="6.3 本章小结">6.3 本章小结</a></li><li><a href=#%e5%8f%82%e8%80%83%e6%96%87%e7%8c%ae-5 aria-label=参考文献>参考文献</a></li></ul></li><li><a href=#%e7%ac%ac7%e7%ab%a0-%e9%87%8f%e5%ad%90%e5%9b%be%e5%83%8f%e8%be%b9%e7%bc%98%e6%a3%80%e6%b5%8b aria-label="第7章 量子图像边缘检测">第7章 量子图像边缘检测</a><ul><li><a href=#71-%e5%9b%be%e5%83%8f%e8%be%b9%e7%bc%98%e6%a3%80%e6%b5%8b%e6%8a%80%e6%9c%af aria-label="7.1 图像边缘检测技术">7.1 图像边缘检测技术</a><ul><li><a href=#711-sobel%e7%ae%97%e5%ad%90%e5%9b%be%e5%83%8f%e8%be%b9%e7%bc%98%e6%a3%80%e6%b5%8b aria-label="7.1.1 Sobel算子图像边缘检测">7.1.1 Sobel算子图像边缘检测</a></li><li><a href=#712-prewitt%e7%ae%97%e5%ad%90%e5%9b%be%e5%83%8f%e8%be%b9%e7%bc%98%e6%a3%80%e6%b5%8b aria-label="7.1.2 Prewitt算子图像边缘检测">7.1.2 Prewitt算子图像边缘检测</a></li><li><a href=#713-kirsch%e7%ae%97%e5%ad%90%e5%9b%be%e5%83%8f%e8%be%b9%e7%bc%98%e6%a3%80%e6%b5%8b aria-label="7.1.3 Kirsch算子图像边缘检测">7.1.3 Kirsch算子图像边缘检测</a></li><li><a href=#714-canny%e7%ae%97%e5%ad%90%e5%9b%be%e5%83%8f%e8%be%b9%e7%bc%98%e6%a3%80%e6%b5%8b aria-label="7.1.4 Canny算子图像边缘检测">7.1.4 Canny算子图像边缘检测</a></li></ul></li><li><a href=#72-%e5%9f%ba%e4%ba%8ekirsch%e7%ae%97%e5%ad%90%e7%9a%84%e9%87%8f%e5%ad%90%e5%9b%be%e5%83%8f%e8%be%b9%e7%bc%98%e6%a3%80%e6%b5%8b%e7%ae%97%e6%b3%95 aria-label="7.2 基于Kirsch算子的量子图像边缘检测算法">7.2 基于Kirsch算子的量子图像边缘检测算法</a><ul><li><a href=#721-%e7%ae%97%e6%b3%95%e6%b5%81%e7%a8%8b aria-label="7.2.1 算法流程">7.2.1 算法流程</a></li><li><a href=#722-%e7%ae%97%e6%b3%95%e5%a4%8d%e6%9d%82%e5%ba%a6%e5%92%8c%e4%bb%bf%e7%9c%9f%e7%bb%93%e6%9e%9c%e5%88%86%e6%9e%90 aria-label="7.2.2 算法复杂度和仿真结果分析">7.2.2 算法复杂度和仿真结果分析</a></li></ul></li><li><a href=#73-%e5%9f%ba%e4%ba%8e%e6%94%b9%e8%bf%9bsobel%e7%ae%97%e5%ad%90%e7%9a%84%e9%87%8f%e5%ad%90%e5%9b%be%e5%83%8f%e8%be%b9%e7%bc%98%e6%a3%80%e6%b5%8b%e7%ae%97%e6%b3%95 aria-label="7.3 基于改进Sobel算子的量子图像边缘检测算法">7.3 基于改进Sobel算子的量子图像边缘检测算法</a><ul><li><a href=#731-%e9%87%8f%e5%ad%90%e7%ba%bf%e8%b7%af%e8%ae%be%e8%ae%a1 aria-label="7.3.1 量子线路设计">7.3.1 量子线路设计</a></li><li><a href=#732-%e7%ae%97%e6%b3%95%e6%b5%81%e7%a8%8b aria-label="7.3.2 算法流程">7.3.2 算法流程</a></li><li><a href=#733-%e7%ae%97%e6%b3%95%e5%ae%9e%e7%8e%b0 aria-label="7.3.3 算法实现">7.3.3 算法实现</a></li><li><a href=#734-%e4%bb%bf%e7%9c%9f%e7%bb%93%e6%9e%9c%e4%b8%8e%e5%88%86%e6%9e%90 aria-label="7.3.4 仿真结果与分析">7.3.4 仿真结果与分析</a></li></ul></li><li><a href=#74-%e6%9c%ac%e7%ab%a0%e5%b0%8f%e7%bb%93 aria-label="7.4 本章小结">7.4 本章小结</a></li><li><a href=#%e5%8f%82%e8%80%83%e6%96%87%e7%8c%ae-6 aria-label=参考文献>参考文献</a></li></ul></li><li><a href=#%e7%ac%ac8%e7%ab%a0-%e9%87%8f%e5%ad%90%e5%9b%be%e5%83%8f%e7%9a%84%e5%88%86%e7%b1%bb%e8%af%86%e5%88%ab aria-label="第8章 量子图像的分类识别">第8章 量子图像的分类识别</a><ul><li><a href=#81-%e9%87%8f%e5%ad%90%e7%a5%9e%e7%bb%8f%e7%bd%91%e7%bb%9c aria-label="8.1 量子神经网络">8.1 量子神经网络</a></li><li><a href=#82-%e9%87%8f%e5%ad%90%e5%8d%b7%e7%a7%af%e7%a5%9e%e7%bb%8f%e7%bd%91%e7%bb%9c aria-label="8.2 量子卷积神经网络">8.2 量子卷积神经网络</a></li><li><a href=#83-%e5%9f%ba%e4%ba%8e%e9%87%8f%e5%ad%90%e5%8d%b7%e7%a7%af%e7%a5%9e%e7%bb%8f%e7%bd%91%e7%bb%9c%e7%9a%84%e6%89%8b%e5%86%99%e6%95%b0%e5%ad%97%e8%af%86%e5%88%ab aria-label="8.3 基于量子卷积神经网络的手写数字识别">8.3 基于量子卷积神经网络的手写数字识别</a><ul><li><a href=#831-%e6%b7%b7%e5%90%88%e9%87%8f%e5%ad%90%e7%bb%8f%e5%85%b8%e5%8d%b7%e7%a7%af%e7%a5%9e%e7%bb%8f%e7%bd%91%e7%bb%9c%e6%a8%a1%e5%9e%8b aria-label="8.3.1 混合量子经典卷积神经网络模型">8.3.1 混合量子经典卷积神经网络模型</a></li><li><a href=#832-%e9%87%8f%e5%ad%90%e5%8d%b7%e7%a7%af%e7%a5%9e%e7%bb%8f%e7%bd%91%e7%bb%9c%e6%a8%a1%e5%9e%8b aria-label="8.3.2 量子卷积神经网络模型">8.3.2 量子卷积神经网络模型</a></li></ul></li><li><a href=#84-%e6%9c%ac%e7%ab%a0%e5%b0%8f%e7%bb%93 aria-label="8.4 本章小结">8.4 本章小结</a></li><li><a href=#%e5%8f%82%e8%80%83%e6%96%87%e7%8c%ae-7 aria-label=参考文献>参考文献</a></li></ul></li><li><a href=#%e7%ac%ac9%e7%ab%a0-%e9%87%8f%e5%ad%90%e5%9b%be%e5%83%8f%e4%bb%bf%e7%9c%9f%e5%ae%9e%e7%8e%b0 aria-label="第9章 量子图像仿真实现">第9章 量子图像仿真实现</a><ul><li><a href=#91-%e4%b8%bb%e6%b5%81%e9%87%8f%e5%ad%90%e4%bb%bf%e7%9c%9fsdk%e4%bb%8b%e7%bb%8d aria-label="9.1 主流量子仿真SDK介绍">9.1 主流量子仿真SDK介绍</a></li><li><a href=#92-frqi%e5%92%8cneqr%e9%87%8f%e5%ad%90%e5%9b%be%e5%83%8f%e7%9a%84%e4%bb%bf%e7%9c%9f aria-label="9.2 FRQI和NEQR量子图像的仿真">9.2 FRQI和NEQR量子图像的仿真</a><ul><li><a href=#921-%e5%88%b6%e5%a4%87frqi%e5%9b%be%e5%83%8f%e9%87%8f%e5%ad%90%e6%80%81 aria-label="9.2.1 制备FRQI图像量子态">9.2.1 制备FRQI图像量子态</a></li><li><a href=#922-%e5%9b%9b%e5%83%8f%e7%b4%a0%e7%81%b0%e5%ba%a6frqi%e5%9b%be%e5%83%8f%e4%bb%bf%e7%9c%9f%e5%ae%9e%e7%8e%b0 aria-label="9.2.2 四像素灰度FRQI图像仿真实现">9.2.2 四像素灰度FRQI图像仿真实现</a></li><li><a href=#923-%e5%88%b6%e5%a4%87neqr%e9%87%8f%e5%ad%90%e6%80%81 aria-label="9.2.3 制备NEQR量子态">9.2.3 制备NEQR量子态</a></li><li><a href=#924-%e5%9b%9b%e5%83%8f%e7%b4%a0%e7%81%b0%e5%ba%a6neqr%e5%9b%be%e5%83%8f%e4%bb%bf%e7%9c%9f%e5%ae%9e%e7%8e%b0 aria-label="9.2.4 四像素灰度NEQR图像仿真实现">9.2.4 四像素灰度NEQR图像仿真实现</a></li></ul></li><li><a href=#93-%e5%b0%8f%e5%9b%be%e5%83%8f%e5%92%8c%e5%a4%a7%e5%9b%be%e5%83%8f%e7%9a%84%e9%87%8f%e5%ad%90%e8%be%b9%e7%bc%98%e6%a3%80%e6%b5%8bqhed%e7%ae%97%e6%b3%95 aria-label="9.3 小图像和大图像的量子边缘检测QHED算法">9.3 小图像和大图像的量子边缘检测QHED算法</a><ul><li><a href=#931-%e9%87%8f%e5%ad%90%e6%a6%82%e7%8e%87%e5%9b%be%e5%83%8f%e7%bc%96%e7%a0%81 aria-label="9.3.1 量子概率图像编码">9.3.1 量子概率图像编码</a></li><li><a href=#932-%e9%87%8f%e5%ad%90hadamard%e8%be%b9%e7%bc%98%e6%a3%80%e6%b5%8b aria-label="9.3.2 量子Hadamard边缘检测">9.3.2 量子Hadamard边缘检测</a></li></ul></li><li><a href=#94-%e6%9c%ac%e7%ab%a0%e5%b0%8f%e7%bb%93 aria-label="9.4 本章小结">9.4 本章小结</a></li><li><a href=#%e5%8f%82%e8%80%83%e6%96%87%e7%8c%ae-8 aria-label=参考文献>参考文献</a></li></ul></li></ul></li><li><a href=#%e9%99%84%e5%bd%95-%e9%87%8f%e5%ad%90%e8%ae%a1%e7%ae%97%e7%bc%96%e7%a8%8b%e5%85%a5%e9%97%a8%e5%86%85%e5%ae%b9%e6%80%bb%e7%bb%93-qiskit aria-label="附录 量子计算编程入门内容总结-Qiskit">附录 量子计算编程入门内容总结-Qiskit</a><ul><li><a href=#1-%e5%9f%ba%e7%a1%80%e7%9f%a5%e8%af%86%e4%b8%8e%e5%89%8d%e8%a8%80 aria-label="1. 基础知识与前言">1. 基础知识与前言</a><ul><li><a href=#11-%e5%9c%a8%e5%ae%98%e7%bd%91%e4%b8%8a%e4%b8%8b%e8%bd%bdpython%e5%92%8cqiskit%e5%bc%80%e5%8f%91%e5%b7%a5%e5%85%b7%e5%8c%85 aria-label="1.1. 在官网上下载Python和Qiskit开发工具包">1.1. 在官网上下载Python和Qiskit开发工具包</a></li><li><a href=#12-python%e5%9f%ba%e7%a1%80%e7%9f%a5%e8%af%86 aria-label="1.2. Python基础知识">1.2. Python基础知识</a></li><li><a href=#13-%e9%87%8f%e5%ad%90%e8%ae%a1%e7%ae%97%e5%9f%ba%e7%a1%80%e7%9f%a5%e8%af%86 aria-label="1.3. 量子计算基础知识">1.3. 量子计算基础知识</a></li></ul></li><li><a href=#2-%e4%bb%8e%e4%bc%a0%e7%bb%9f%e7%ae%97%e6%b3%95%e5%88%b0%e9%87%8f%e5%ad%90%e7%ae%97%e6%b3%95 aria-label="2. 从传统算法到量子算法">2. 从传统算法到量子算法</a><ul><li><a href=#21deutsch-jozsa%e7%ae%97%e6%b3%95 aria-label=2.1. Deutsch-Jozsa算法>2.1. Deutsch-Jozsa算法</a></li><li><a href=#22simon%e7%ae%97%e6%b3%95 aria-label=2.2. Simon算法>2.2. Simon算法</a></li></ul></li><li><a href=#3-%e9%87%8f%e5%ad%90%e8%ae%a1%e7%ae%97%e5%9c%a8%e5%af%86%e7%a0%81%e5%ad%a6%e4%b8%ad%e7%9a%84%e5%ba%94%e7%94%a8 aria-label="3. 量子计算在密码学中的应用">3. 量子计算在密码学中的应用</a><ul><li><a href=#31%e9%87%8f%e5%ad%90%e5%af%86%e9%92%a5%e5%88%86%e5%8f%91qkd aria-label=3.1. 量子密钥分发 (QKD)>3.1. 量子密钥分发 (QKD)</a></li></ul></li><li><a href=#4-%e9%87%8f%e5%ad%90%e6%9c%ba%e5%99%a8%e5%ad%a6%e4%b9%a0 aria-label="4. 量子机器学习">4. 量子机器学习</a></li></ul></li></ul></div></details></div><div class=post-content><h1 id=概论>概论<a hidden class=anchor aria-hidden=true href=#概论>#</a></h1><h2 id=前言>前言<a hidden class=anchor aria-hidden=true href=#前言>#</a></h2><p>严格来说，我没有读懂这本书，因为我只懂得量子计算的皮毛。</p><h2 id=书籍简介>书籍简介<a hidden class=anchor aria-hidden=true href=#书籍简介>#</a></h2><p><img loading=lazy src=https://setsailtowardstianhan.ip-ddns.com/blog/283f62b678e06bda70061a44d3ab9d3b.png></p><p>作　者： 马鸿洋 邱田会 王淑梅 田艳兵 史鹏</p><p>出版社： 人民邮电出版社</p><p>ISBN： 9787115633941</p><p>出版时间： 2024-08-01</p><h2 id=内容简介>内容简介<a hidden class=anchor aria-hidden=true href=#内容简介>#</a></h2><p>本书系统阐述了量子图像处理及其关键技术。本书内容共分9章，分别介绍了量子图像处理的研究意义和背景与现状、量子图像表示模型、量子图像处理算法、量子图像恢复、量子图像加密、量子水印、量子图像边缘检测、量子图像的分类识别、量子图像仿真实现。本书旨在为量子图像处理领域的科研人员提供具有较强实用性的参考，可作为物理和计算机专业开设量子计算相关课程的教学参考书，也可作为量子计算与量子图像处理的短期专题讲座培训用书。本书结构清晰、内容翔实，对初次接触量子图像处理领域的研究人员，特别是非物理专业的科研技术人员具有一定的参考价值。</p><h2 id=作者简介>作者简介<a hidden class=anchor aria-hidden=true href=#作者简介>#</a></h2><p>马鸿洋，2019—2022年山东省物理学类专业及大学物理课程教学指导委员会委员；2018至今教育 部高等学校物理学类专业教学指导委员会华东地区工作委员会委员、量子密码委员会委员、中国电子学信息论分委会委员、大数据与智能信息处理技术委员会委员、山东省物理学会理事会理事、山东省光学工程学会理事、青岛市物理学会理事会理事。 主要研究方向为网络空间安 全、量子保密通信、量子计算、机器学习和深度学习。完成教学科研课题一项，获青岛理工大学优 秀科研成果三等奖一项。</p><p>邱田会，青岛理工大学副教授。主要研究方向为量子光学和量子信息。主持国家自然科学基金青年基金和理论物理专款各一项，主持山东省自然科学基金培养基金项目一项， 作为项目组主要成员参与国家和省部级项目6项。在光的可逆存储、原子相干调控、电磁诱导周期介质性质和应用等方面发表SCI论文20余篇。</p><h1 id=正文摘录>正文摘录<a hidden class=anchor aria-hidden=true href=#正文摘录>#</a></h1><h2 id=第1章-绪论>第1章 绪论<a hidden class=anchor aria-hidden=true href=#第1章-绪论>#</a></h2><h3 id=11-量子图像处理的研究意义>1.1 量子图像处理的研究意义<a hidden class=anchor aria-hidden=true href=#11-量子图像处理的研究意义>#</a></h3><h3 id=12-量子图像处理的背景与现状>1.2 量子图像处理的背景与现状<a hidden class=anchor aria-hidden=true href=#12-量子图像处理的背景与现状>#</a></h3><h3 id=参考文献>参考文献<a hidden class=anchor aria-hidden=true href=#参考文献>#</a></h3><h2 id=第2章-量子图像表示模型>第2章 量子图像表示模型<a hidden class=anchor aria-hidden=true href=#第2章-量子图像表示模型>#</a></h2><h3 id=21-量子图像表示模型及其特点>2.1 量子图像表示模型及其特点<a hidden class=anchor aria-hidden=true href=#21-量子图像表示模型及其特点>#</a></h3><h4 id=211-qubit-lattice模型>2.1.1 Qubit Lattice模型<a hidden class=anchor aria-hidden=true href=#211-qubit-lattice模型>#</a></h4><h4 id=212-real-ket模型>2.1.2 Real Ket模型<a hidden class=anchor aria-hidden=true href=#212-real-ket模型>#</a></h4><h4 id=213-entangled-image模型>2.1.3 Entangled Image模型<a hidden class=anchor aria-hidden=true href=#213-entangled-image模型>#</a></h4><h4 id=214-frqi模型>2.1.4 FRQI模型<a hidden class=anchor aria-hidden=true href=#214-frqi模型>#</a></h4><h4 id=215-neqr模型>2.1.5 NEQR模型<a hidden class=anchor aria-hidden=true href=#215-neqr模型>#</a></h4><h4 id=216-gqir模型>2.1.6 GQIR模型<a hidden class=anchor aria-hidden=true href=#216-gqir模型>#</a></h4><h4 id=217-naqss模型>2.1.7 NAQSS模型<a hidden class=anchor aria-hidden=true href=#217-naqss模型>#</a></h4><h4 id=218-qrci模型>2.1.8 QRCI模型<a hidden class=anchor aria-hidden=true href=#218-qrci模型>#</a></h4><h4 id=219-qirhsi模型>2.1.9 QIRHSI模型<a hidden class=anchor aria-hidden=true href=#219-qirhsi模型>#</a></h4><h3 id=22-量子图像表示模型分类>2.2 量子图像表示模型分类<a hidden class=anchor aria-hidden=true href=#22-量子图像表示模型分类>#</a></h3><h4 id=221-量子图像颜色模型>2.2.1 量子图像颜色模型<a hidden class=anchor aria-hidden=true href=#221-量子图像颜色模型>#</a></h4><p>按照颜色信息不同可分为以下几种：</p><ul><li>基于二进制的量子图像表示模型</li><li>基于灰度</li><li>基于RGB</li><li>基于红外图像</li></ul><h4 id=222-量子图像坐标模型>2.2.2 量子图像坐标模型<a hidden class=anchor aria-hidden=true href=#222-量子图像坐标模型>#</a></h4><p>利用不同的坐标系捕捉图像信息：</p><ul><li>基于笛卡尔坐标系的量子图像表示模型</li><li>基于对数极坐标系</li><li>基于多维表示</li></ul><h3 id=23-本章小结>2.3 本章小结<a hidden class=anchor aria-hidden=true href=#23-本章小结>#</a></h3><h3 id=参考文献-1>参考文献<a hidden class=anchor aria-hidden=true href=#参考文献-1>#</a></h3><h2 id=第3章-量子图像处理算法>第3章 量子图像处理算法<a hidden class=anchor aria-hidden=true href=#第3章-量子图像处理算法>#</a></h2><h3 id=31-几何变换>3.1 几何变换<a hidden class=anchor aria-hidden=true href=#31-几何变换>#</a></h3><p>本节介绍了基于n个量子比特的标准任意叠加态（NASS）实现图像几何变换。</p><h4 id=311-两点交换>3.1.1 两点交换<a hidden class=anchor aria-hidden=true href=#311-两点交换>#</a></h4><h4 id=312-对称翻转>3.1.2 对称翻转<a hidden class=anchor aria-hidden=true href=#312-对称翻转>#</a></h4><h4 id=313-局部翻转>3.1.3 局部翻转<a hidden class=anchor aria-hidden=true href=#313-局部翻转>#</a></h4><h4 id=314-正交旋转>3.1.4 正交旋转<a hidden class=anchor aria-hidden=true href=#314-正交旋转>#</a></h4><h3 id=32-色彩处理>3.2 色彩处理<a hidden class=anchor aria-hidden=true href=#32-色彩处理>#</a></h3><h4 id=321-量子图像的颜色运算>3.2.1 量子图像的颜色运算<a hidden class=anchor aria-hidden=true href=#321-量子图像的颜色运算>#</a></h4><p>NEQR模型可以方便地处理图像的颜色信息。</p><h4 id=322-伪彩色处理>3.2.2 伪彩色处理<a hidden class=anchor aria-hidden=true href=#322-伪彩色处理>#</a></h4><h4 id=323-量子色图>3.2.3 量子色图<a hidden class=anchor aria-hidden=true href=#323-量子色图>#</a></h4><h4 id=324-量子伪彩色编码实现>3.2.4 量子伪彩色编码实现<a hidden class=anchor aria-hidden=true href=#324-量子伪彩色编码实现>#</a></h4><h3 id=33-图像分割>3.3 图像分割<a hidden class=anchor aria-hidden=true href=#33-图像分割>#</a></h3><h4 id=331-基于量子搜索的图像分割>3.3.1 基于量子搜索的图像分割<a hidden class=anchor aria-hidden=true href=#331-基于量子搜索的图像分割>#</a></h4><h4 id=332-量子图像分割线路>3.3.2 量子图像分割线路<a hidden class=anchor aria-hidden=true href=#332-量子图像分割线路>#</a></h4><h4 id=333-分割后量子图像的显示>3.3.3 分割后量子图像的显示<a hidden class=anchor aria-hidden=true href=#333-分割后量子图像的显示>#</a></h4><h3 id=34-本章小结>3.4 本章小结<a hidden class=anchor aria-hidden=true href=#34-本章小结>#</a></h3><h3 id=参考文献-2>参考文献<a hidden class=anchor aria-hidden=true href=#参考文献-2>#</a></h3><h2 id=第4章-量子图像恢复>第4章 量子图像恢复<a hidden class=anchor aria-hidden=true href=#第4章-量子图像恢复>#</a></h2><h3 id=41-量子图像去噪算法>4.1 量子图像去噪算法<a hidden class=anchor aria-hidden=true href=#41-量子图像去噪算法>#</a></h3><h4 id=411-基于neqr模型的去噪算法>4.1.1 基于NEQR模型的去噪算法<a hidden class=anchor aria-hidden=true href=#411-基于neqr模型的去噪算法>#</a></h4><p>本节主要考虑两种常见噪声，即椒盐噪声和高斯噪声。</p><p>本节主要介绍三张图像去噪算法：</p><ul><li>Q均值滤波算法：采用均值滤波方法处理椒盐噪声</li><li>Q高斯滤波算法：主要用于滤除高斯噪声</li><li>Q自适应滤波算法：主要用于处理含有未知噪声的图像</li></ul><h4 id=412-基于量子小波变换的图像去噪方法>4.1.2 基于量子小波变换的图像去噪方法<a hidden class=anchor aria-hidden=true href=#412-基于量子小波变换的图像去噪方法>#</a></h4><p>Daubechies四阶小波核</p><p>Cooley-Tukey FFT</p><h3 id=42-量子图像复原算法>4.2 量子图像复原算法<a hidden class=anchor aria-hidden=true href=#42-量子图像复原算法>#</a></h3><h4 id=421-基于r-l算法的量子图像复原算法>4.2.1 基于R-L算法的量子图像复原算法<a hidden class=anchor aria-hidden=true href=#421-基于r-l算法的量子图像复原算法>#</a></h4><h4 id=422-基于约束的最小二乘法滤波的量子图像复原算法>4.2.2 基于约束的最小二乘法滤波的量子图像复原算法<a hidden class=anchor aria-hidden=true href=#422-基于约束的最小二乘法滤波的量子图像复原算法>#</a></h4><h3 id=43-本章小结>4.3 本章小结<a hidden class=anchor aria-hidden=true href=#43-本章小结>#</a></h3><h3 id=参考文献-3>参考文献<a hidden class=anchor aria-hidden=true href=#参考文献-3>#</a></h3><h2 id=第5章-量子图像加密>第5章 量子图像加密<a hidden class=anchor aria-hidden=true href=#第5章-量子图像加密>#</a></h2><h3 id=51-图像置乱算法>5.1 图像置乱算法<a hidden class=anchor aria-hidden=true href=#51-图像置乱算法>#</a></h3><h4 id=511-量子仿射变换>5.1.1 量子仿射变换<a hidden class=anchor aria-hidden=true href=#511-量子仿射变换>#</a></h4><p>量子仿射变换中应用较广泛的是阿诺德变换和斐波那契变换。利用阿诺德变换和斐波那契变换能够将一幅图像置乱，从而使一幅有意义的图像变成一幅毫无意义的图像。</p><h4 id=512-量子hilbert变换>5.1.2 量子Hilbert变换<a hidden class=anchor aria-hidden=true href=#512-量子hilbert变换>#</a></h4><p>Hilbert曲线是一种连续的参数曲线，类似于Z曲线、格雷码等。</p><h4 id=513-量子随机行走>5.1.3 量子随机行走<a hidden class=anchor aria-hidden=true href=#513-量子随机行走>#</a></h4><p>马尔可夫过程</p><h4 id=514-骑士巡游变换>5.1.4 骑士巡游变换<a hidden class=anchor aria-hidden=true href=#514-骑士巡游变换>#</a></h4><p>模拟骑士在棋盘中的巡游</p><h3 id=52-图像加密算法>5.2 图像加密算法<a hidden class=anchor aria-hidden=true href=#52-图像加密算法>#</a></h3><h4 id=521-离散余弦变换>5.2.1 离散余弦变换<a hidden class=anchor aria-hidden=true href=#521-离散余弦变换>#</a></h4><h4 id=522-dna编码>5.2.2 DNA编码<a hidden class=anchor aria-hidden=true href=#522-dna编码>#</a></h4><h4 id=523-混沌映射>5.2.3 混沌映射<a hidden class=anchor aria-hidden=true href=#523-混沌映射>#</a></h4><ol><li>Rossler混沌模型</li><li>Lorenz混沌模型</li></ol><h4 id=524-量子受控翻转>5.2.4 量子受控翻转<a hidden class=anchor aria-hidden=true href=#524-量子受控翻转>#</a></h4><h3 id=53-量子图像加密方案设计>5.3 量子图像加密方案设计<a hidden class=anchor aria-hidden=true href=#53-量子图像加密方案设计>#</a></h3><h4 id=531-基于交替量子随机行走和离散余弦变换的图像加解密方案>5.3.1 基于交替量子随机行走和离散余弦变换的图像加解密方案<a hidden class=anchor aria-hidden=true href=#531-基于交替量子随机行走和离散余弦变换的图像加解密方案>#</a></h4><h4 id=532-基于dna编码与交替量子随机行走的图像加密方案>5.3.2 基于DNA编码与交替量子随机行走的图像加密方案<a hidden class=anchor aria-hidden=true href=#532-基于dna编码与交替量子随机行走的图像加密方案>#</a></h4><h4 id=533-基于量子随机行走和多维混沌映射的图像加密方案>5.3.3 基于量子随机行走和多维混沌映射的图像加密方案<a hidden class=anchor aria-hidden=true href=#533-基于量子随机行走和多维混沌映射的图像加密方案>#</a></h4><p>流程包括以下几个步骤：</p><ol><li>图像分割（使用高斯金字塔）</li><li>概率矩阵的生成和转化</li><li>阿诺德变换置乱</li><li>利用欧氏距离和汉明距离求序列</li><li>密钥生成</li><li>盲水印的嵌入和提取</li></ol><h4 id=534-基于量子受控翻转的图像加密方案>5.3.4 基于量子受控翻转的图像加密方案<a hidden class=anchor aria-hidden=true href=#534-基于量子受控翻转的图像加密方案>#</a></h4><p>NCQI模型是NEQR模型的改进版</p><h3 id=54-本章小结>5.4 本章小结<a hidden class=anchor aria-hidden=true href=#54-本章小结>#</a></h3><h3 id=参考文献-4>参考文献<a hidden class=anchor aria-hidden=true href=#参考文献-4>#</a></h3><h2 id=第6章-量子水印>第6章 量子水印<a hidden class=anchor aria-hidden=true href=#第6章-量子水印>#</a></h2><p>图像信息隐藏的两大手段包括图像加密和数字水印。</p><p>可用于传递秘密信息和版权保护等领域。</p><h3 id=61-量子信息隐藏>6.1 量子信息隐藏<a hidden class=anchor aria-hidden=true href=#61-量子信息隐藏>#</a></h3><h4 id=611-量子lsb算法>6.1.1 量子LSB算法<a hidden class=anchor aria-hidden=true href=#611-量子lsb算法>#</a></h4><h4 id=612-量子傅里叶变换>6.1.2 量子傅里叶变换<a hidden class=anchor aria-hidden=true href=#612-量子傅里叶变换>#</a></h4><h4 id=613-量子小波变换>6.1.3 量子小波变换<a hidden class=anchor aria-hidden=true href=#613-量子小波变换>#</a></h4><h3 id=62-量子水印算法>6.2 量子水印算法<a hidden class=anchor aria-hidden=true href=#62-量子水印算法>#</a></h3><h4 id=621-基于量子lsb分块的水印算法>6.2.1 基于量子LSB分块的水印算法<a hidden class=anchor aria-hidden=true href=#621-基于量子lsb分块的水印算法>#</a></h4><h4 id=622-基于量子傅里叶变换的量子水印算法>6.2.2 基于量子傅里叶变换的量子水印算法<a hidden class=anchor aria-hidden=true href=#622-基于量子傅里叶变换的量子水印算法>#</a></h4><h4 id=623-基于量子haar小波变换的水印算法>6.2.3 基于量子Haar小波变换的水印算法<a hidden class=anchor aria-hidden=true href=#623-基于量子haar小波变换的水印算法>#</a></h4><h4 id=624-基于莫尔条纹的量子信息隐藏>6.2.4 基于莫尔条纹的量子信息隐藏<a hidden class=anchor aria-hidden=true href=#624-基于莫尔条纹的量子信息隐藏>#</a></h4><h3 id=63-本章小结>6.3 本章小结<a hidden class=anchor aria-hidden=true href=#63-本章小结>#</a></h3><h3 id=参考文献-5>参考文献<a hidden class=anchor aria-hidden=true href=#参考文献-5>#</a></h3><h2 id=第7章-量子图像边缘检测>第7章 量子图像边缘检测<a hidden class=anchor aria-hidden=true href=#第7章-量子图像边缘检测>#</a></h2><h3 id=71-图像边缘检测技术>7.1 图像边缘检测技术<a hidden class=anchor aria-hidden=true href=#71-图像边缘检测技术>#</a></h3><h4 id=711-sobel算子图像边缘检测>7.1.1 Sobel算子图像边缘检测<a hidden class=anchor aria-hidden=true href=#711-sobel算子图像边缘检测>#</a></h4><h4 id=712-prewitt算子图像边缘检测>7.1.2 Prewitt算子图像边缘检测<a hidden class=anchor aria-hidden=true href=#712-prewitt算子图像边缘检测>#</a></h4><h4 id=713-kirsch算子图像边缘检测>7.1.3 Kirsch算子图像边缘检测<a hidden class=anchor aria-hidden=true href=#713-kirsch算子图像边缘检测>#</a></h4><h4 id=714-canny算子图像边缘检测>7.1.4 Canny算子图像边缘检测<a hidden class=anchor aria-hidden=true href=#714-canny算子图像边缘检测>#</a></h4><h3 id=72-基于kirsch算子的量子图像边缘检测算法>7.2 基于Kirsch算子的量子图像边缘检测算法<a hidden class=anchor aria-hidden=true href=#72-基于kirsch算子的量子图像边缘检测算法>#</a></h3><h4 id=721-算法流程>7.2.1 算法流程<a hidden class=anchor aria-hidden=true href=#721-算法流程>#</a></h4><h4 id=722-算法复杂度和仿真结果分析>7.2.2 算法复杂度和仿真结果分析<a hidden class=anchor aria-hidden=true href=#722-算法复杂度和仿真结果分析>#</a></h4><h3 id=73-基于改进sobel算子的量子图像边缘检测算法>7.3 基于改进Sobel算子的量子图像边缘检测算法<a hidden class=anchor aria-hidden=true href=#73-基于改进sobel算子的量子图像边缘检测算法>#</a></h3><h4 id=731-量子线路设计>7.3.1 量子线路设计<a hidden class=anchor aria-hidden=true href=#731-量子线路设计>#</a></h4><h4 id=732-算法流程>7.3.2 算法流程<a hidden class=anchor aria-hidden=true href=#732-算法流程>#</a></h4><h4 id=733-算法实现>7.3.3 算法实现<a hidden class=anchor aria-hidden=true href=#733-算法实现>#</a></h4><h4 id=734-仿真结果与分析>7.3.4 仿真结果与分析<a hidden class=anchor aria-hidden=true href=#734-仿真结果与分析>#</a></h4><h3 id=74-本章小结>7.4 本章小结<a hidden class=anchor aria-hidden=true href=#74-本章小结>#</a></h3><h3 id=参考文献-6>参考文献<a hidden class=anchor aria-hidden=true href=#参考文献-6>#</a></h3><h2 id=第8章-量子图像的分类识别>第8章 量子图像的分类识别<a hidden class=anchor aria-hidden=true href=#第8章-量子图像的分类识别>#</a></h2><h3 id=81-量子神经网络>8.1 量子神经网络<a hidden class=anchor aria-hidden=true href=#81-量子神经网络>#</a></h3><h3 id=82-量子卷积神经网络>8.2 量子卷积神经网络<a hidden class=anchor aria-hidden=true href=#82-量子卷积神经网络>#</a></h3><h3 id=83-基于量子卷积神经网络的手写数字识别>8.3 基于量子卷积神经网络的手写数字识别<a hidden class=anchor aria-hidden=true href=#83-基于量子卷积神经网络的手写数字识别>#</a></h3><h4 id=831-混合量子经典卷积神经网络模型>8.3.1 混合量子经典卷积神经网络模型<a hidden class=anchor aria-hidden=true href=#831-混合量子经典卷积神经网络模型>#</a></h4><h4 id=832-量子卷积神经网络模型>8.3.2 量子卷积神经网络模型<a hidden class=anchor aria-hidden=true href=#832-量子卷积神经网络模型>#</a></h4><h3 id=84-本章小结>8.4 本章小结<a hidden class=anchor aria-hidden=true href=#84-本章小结>#</a></h3><h3 id=参考文献-7>参考文献<a hidden class=anchor aria-hidden=true href=#参考文献-7>#</a></h3><h2 id=第9章-量子图像仿真实现>第9章 量子图像仿真实现<a hidden class=anchor aria-hidden=true href=#第9章-量子图像仿真实现>#</a></h2><p>根据不同的后端处理系统，量子软件开发工具分为两大类：一类是可以访问量子处理器的SDK，另一类是基于量子计算模拟器的SDK。</p><p>由于量子图像多来自经典世界，需要将经典图像编码为量子信息后再进行处理，而目前尚无可有效完成此项工作的量子计算机，因此量子图像需要通过基于量子计算模拟器的SDK来进行仿真实现。</p><h3 id=91-主流量子仿真sdk介绍>9.1 主流量子仿真SDK介绍<a hidden class=anchor aria-hidden=true href=#91-主流量子仿真sdk介绍>#</a></h3><ol><li>Qiskit</li><li>QPanda</li><li>Azure Quantum（Q#）</li></ol><h3 id=92-frqi和neqr量子图像的仿真>9.2 FRQI和NEQR量子图像的仿真<a hidden class=anchor aria-hidden=true href=#92-frqi和neqr量子图像的仿真>#</a></h3><h4 id=921-制备frqi图像量子态>9.2.1 制备FRQI图像量子态<a hidden class=anchor aria-hidden=true href=#921-制备frqi图像量子态>#</a></h4><h4 id=922-四像素灰度frqi图像仿真实现>9.2.2 四像素灰度FRQI图像仿真实现<a hidden class=anchor aria-hidden=true href=#922-四像素灰度frqi图像仿真实现>#</a></h4><h4 id=923-制备neqr量子态>9.2.3 制备NEQR量子态<a hidden class=anchor aria-hidden=true href=#923-制备neqr量子态>#</a></h4><h4 id=924-四像素灰度neqr图像仿真实现>9.2.4 四像素灰度NEQR图像仿真实现<a hidden class=anchor aria-hidden=true href=#924-四像素灰度neqr图像仿真实现>#</a></h4><h3 id=93-小图像和大图像的量子边缘检测qhed算法>9.3 小图像和大图像的量子边缘检测QHED算法<a hidden class=anchor aria-hidden=true href=#93-小图像和大图像的量子边缘检测qhed算法>#</a></h3><h4 id=931-量子概率图像编码>9.3.1 量子概率图像编码<a hidden class=anchor aria-hidden=true href=#931-量子概率图像编码>#</a></h4><h4 id=932-量子hadamard边缘检测>9.3.2 量子Hadamard边缘检测<a hidden class=anchor aria-hidden=true href=#932-量子hadamard边缘检测>#</a></h4><h3 id=94-本章小结>9.4 本章小结<a hidden class=anchor aria-hidden=true href=#94-本章小结>#</a></h3><h3 id=参考文献-8>参考文献<a hidden class=anchor aria-hidden=true href=#参考文献-8>#</a></h3><h1 id=附录-量子计算编程入门内容总结-qiskit>附录 <a href=https://zhuanlan.zhihu.com/p/667681298>量子计算编程入门内容总结-Qiskit</a><a hidden class=anchor aria-hidden=true href=#附录-量子计算编程入门内容总结-qiskit>#</a></h1><h2 id=1-基础知识与前言>1. 基础知识与前言<a hidden class=anchor aria-hidden=true href=#1-基础知识与前言>#</a></h2><p>除了理论内容之外，在<strong>量子SDK (Quantum Software Development Kit)</strong> 上对于程序和算法的实现同样重要，本文将以之前文章的内容为基础探索<a href="https://zhida.zhihu.com/search?content_id=236503607&amp;content_type=Article&amp;match_order=1&amp;q=Qiskit&amp;zhida_source=entity">Qiskit</a>的使用方法：</p><p><a href=https://zhuanlan.zhihu.com/p/665210284><img loading=lazy src="https://pic1.zhimg.com/v2-3e731f21df134527e0ab18e44eb72875.png?source=7e7ef6e2&needBackground=1">Mercury：量子计算入门内容总结501 赞同 · 14 评论</a> 文章</p><p>同样，在开始正式学习Qiskit之前，我们需要一些基本的计算机知识，熟悉的同学可以直接跳过这个章节，这里我们主要是基于<a href="https://zhida.zhihu.com/search?content_id=236503607&amp;content_type=Article&amp;match_order=1&amp;q=Python&amp;zhida_source=entity">Python</a>来编程。</p><h3 id=11-在官网上下载python和qiskit开发工具包>1.1. 在官网上下载Python和Qiskit开发工具包<a hidden class=anchor aria-hidden=true href=#11-在官网上下载python和qiskit开发工具包>#</a></h3><p>笔者主要使用的是Anaconda Python，可以在<a href="https://link.zhihu.com/?target=https%3A//www.anaconda.com/download">官网</a>上直接下载；之后在terminal中输入 (笔者使用的是macOS系统) 来下载Qiskit开发工具包：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python3 data-lang=python3><span class=line><span class=cl><span class=n>pip</span> <span class=n>install</span> <span class=n>qiskit</span>
</span></span></code></pre></td></tr></table></div></div><p>之后我们可以在terminal中通过输入如下的代码跳转到<a href="https://zhida.zhihu.com/search?content_id=236503607&amp;content_type=Article&amp;match_order=1&amp;q=Jupyter+Notebook&amp;zhida_source=entity">Jupyter Notebook</a>的页面，Jupyter Notebook可能是结合编程、文本和图像的最佳方式：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>jupyter notebook
</span></span></code></pre></td></tr></table></div></div><p>在Jupyter Notebook创建一个新文件之后输入如下的代码我们便可以检验是否下载好并且是否下载了最新的版本：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>import qiskit
</span></span><span class=line><span class=cl>qiskit.__qiskit_version__
</span></span></code></pre></td></tr></table></div></div><p>这里我的输出结果为如下所示，说明我的版本为0.45.0，在Qiskit官网上可以发现是截止这篇文章发布前的最新版。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>{&#39;qiskit&#39;: &#39;0.45.0&#39;, &#39;qiskit-aer&#39;: &#39;0.13.0&#39;, &#39;qiskit-ignis&#39;: None, &#39;qiskit-ibmq-provider&#39;: &#39;0.20.2&#39;, &#39;qiskit-nature&#39;: None, &#39;qiskit-finance&#39;: None, &#39;qiskit-optimization&#39;: None, &#39;qiskit-machine-learning&#39;: None}
</span></span></code></pre></td></tr></table></div></div><p>之后我们需要在<a href="https://link.zhihu.com/?target=https%3A//quantum-computing.ibm.com/">IBM的官网</a>上注册账号来获取API代码，这是我们和IBM的量子计算机链接的途径，在个人主页中找到后复制到如下的代码中，我们就可以把我们在自己电脑上创建的量子电路传输给IBM的量子计算机并得到结果。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>from qiskit import IBMQ
</span></span><span class=line><span class=cl>IBMQ.save_account(&#39;在这里输入你的API代码&#39;)
</span></span><span class=line><span class=cl>IBMQ.load_account()
</span></span></code></pre></td></tr></table></div></div><h3 id=12-python基础知识>1.2. Python基础知识<a hidden class=anchor aria-hidden=true href=#12-python基础知识>#</a></h3><p>这里的内容不是本文的重点，以下的内容默认读者对Python中的基础语法有所掌握。</p><h3 id=13-量子计算基础知识>1.3. 量子计算基础知识<a hidden class=anchor aria-hidden=true href=#13-量子计算基础知识>#</a></h3><p>在之前的内容中，我们学习了使用<a href="https://zhida.zhihu.com/search?content_id=236503607&amp;content_type=Article&amp;match_order=1&amp;q=%E6%80%81%E5%8F%A0%E5%8A%A0%E5%8E%9F%E7%90%86&amp;zhida_source=entity">态叠加原理</a>来表示一个量子比特的状态，即用以  和  为基向量的线性组合  来表示，那么我们如何在Qiskit开发工具包中表示这个状态呢？首先我们引入我们需要使用的工具：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>from qiskit import QuantumCircuit, assemble, Aer
</span></span><span class=line><span class=cl>from qiskit.visualization import plot_histogram, plot_bloch_vector
</span></span><span class=line><span class=cl>from math import sqrt, pi
</span></span></code></pre></td></tr></table></div></div><p>其次我们建立一个单量子比特的电路，通过之前的学习我们知道一个量子比特总是以  开始的，在Qiskit中我们可以使用initialize()将它转化成任何状态。比如在这里我们将  输入进去，并告诉它哪一个量子比特是我们想初始化的：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>qc = QuantumCircuit(1)  # 建立一个单量子比特电路
</span></span><span class=line><span class=cl>initial_state = [0,1]   # 定义初始状态 |1&gt;
</span></span><span class=line><span class=cl>qc.initialize(initial_state, 0) # 对第0个量子比特应用初始化的操作
</span></span><span class=line><span class=cl>qc.draw()  # 通过这条指令可以展示我们设置的量子电路
</span></span></code></pre></td></tr></table></div></div><p>之后我们可以使用Qiskit的模拟器来查看量子比特的最终状态，为了从电路中获得结果，我们使用run来执行电路，最后我们可以通过.result()来获得结果。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>sim = Aer.get_backend(&#39;aer_simulator&#39;)  # 告诉Qiskit如何模拟我们的电路
</span></span><span class=line><span class=cl>qc.save_statevector()   # 告诉模拟器保存statevector
</span></span><span class=line><span class=cl>qobj = assemble(qc)     # 从电路中创建一个Qobj来给模拟器进行模拟
</span></span><span class=line><span class=cl>result = sim.run(qobj).result() # 进行模拟并显示结果
</span></span><span class=line><span class=cl>out_state = result.get_statevector()
</span></span><span class=line><span class=cl>print(out_state) # 用statevector的形式展示最后的结果
</span></span></code></pre></td></tr></table></div></div><p>我最后得到如下的结果：Python通常通过  来表示复数里的  ，因此我这里得到的  。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>Statevector([0.+0.j, 1.+0.j],
</span></span><span class=line><span class=cl>            dims=(2,))
</span></span></code></pre></td></tr></table></div></div><p>现在让我们像真正的量子计算机那样测量我们的量子比特并观察我们可以得到的结果：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>qc.measure_all()
</span></span><span class=line><span class=cl>qc.draw()
</span></span></code></pre></td></tr></table></div></div><p>我们可以得到这样的图像：</p><p><img loading=lazy src=https://pic1.zhimg.com/v2-7b3e0648c7c1f412d55276e03f87ff80_1440w.jpg></p><p>我们得到的量子电路</p><p>为了和之前得到的statevector结果不一样，我们可以使用.get_counts()来获得测量出0和1的数量：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>qobj = assemble(qc)
</span></span><span class=line><span class=cl>result = sim.run(qobj).result()
</span></span><span class=line><span class=cl>counts = result.get_counts()
</span></span><span class=line><span class=cl>plot_histogram(counts)
</span></span></code></pre></td></tr></table></div></div><p>从得到的结果中我们看出，我们100%会测量出  。</p><p><img loading=lazy src=https://picx.zhimg.com/v2-01fcb649cc57bfc8a3d4ab50ae013fdf_1440w.jpg></p><p>我们得到的测量结果</p><p>接下来如果我们将输入的状态换成叠加态  ，看看会发生什么？</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>initial_state = [1/sqrt(2), 1j/sqrt(2)]  # 定义状态 |q_0&gt;
</span></span><span class=line><span class=cl>qc = QuantumCircuit(1) # 我们必须重新定义qc
</span></span><span class=line><span class=cl>qc.initialize(initial_state, 0) # 对第0个量子比特应用初始化的操作
</span></span><span class=line><span class=cl>qc.save_statevector() # 保存statevector
</span></span><span class=line><span class=cl>qobj = assemble(qc)
</span></span><span class=line><span class=cl>state = sim.run(qobj).result().get_statevector() # 执行电路
</span></span><span class=line><span class=cl>print(state)           # 输出结果
</span></span></code></pre></td></tr></table></div></div><p>之后我们可以得到如下的结果，并重复以上的操作，我们可以得到测量的结果，即我们有50%的几率测量出  ，也有50%的几率测量出  。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>qobj = assemble(qc)
</span></span><span class=line><span class=cl>results = sim.run(qobj).result().get_counts()
</span></span><span class=line><span class=cl>plot_histogram(results)
</span></span></code></pre></td></tr></table></div></div><p><img loading=lazy src=https://pica.zhimg.com/v2-e3ec345591ef0eb19dc42a900c99ec44_1440w.jpg></p><p>我们得到的测量结果</p><p>在之前我们同样也学习了<strong>布洛赫球(Bloch sphere)</strong> 的表达形式，那么我们怎么使用Qiskit来形象的表示布洛赫球呢？首先我们需要通过如下的代码安装&rsquo;qiskit_textbook&rsquo;模块：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>pip install git+https://github.com/qiskit-community/qiskit-textbook.git#subdirectory=qiskit-textbook-src
</span></span></code></pre></td></tr></table></div></div><p>之后我们再使用如下的代码就可以表示布洛赫球了，这里我们定义  (注意这里可能需要根据情况从math中引入pi或者从numpy库中导入)：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>from qiskit_textbook.widgets import plot_bloch_vector_spherical
</span></span><span class=line><span class=cl>coords = [pi/2,0,1] # 输入[Theta, Phi, Radius]
</span></span><span class=line><span class=cl>plot_bloch_vector_spherical(coords) # 布洛赫向量
</span></span></code></pre></td></tr></table></div></div><p>我们可以得到如下的结果：</p><p><img loading=lazy src=https://picx.zhimg.com/v2-050186c3b2019fb1aa50363d02b258b3_1440w.jpg></p><p>我们得到的结果</p><p>除了对量子比特的描述之外，我们在之前的内容里也了解了很多有关单比特量子门的内容，我们下面就具体看一下如何在Qiskit中表示量子门，首先是最常见的  门，  门和  门，我们可以用如下的形式来表示：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>qc = QuantumCircuit(1) # 首先我们先创建一个单量子比特电路
</span></span><span class=line><span class=cl>qc.x(0) # 在第0个量子比特上放上X门
</span></span><span class=line><span class=cl>qc.draw() # 画出我们设计的电路
</span></span></code></pre></td></tr></table></div></div><p>我们可以得到：</p><p><img loading=lazy src=https://picx.zhimg.com/v2-6ef5748d06678e6dff9fb13584543faf_1440w.jpg></p><p>我们得到的结果</p><p>类似的，我们可以在同样的一条电路上放上  门和 门：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>from qiskit_textbook.widgets import gate_demo
</span></span><span class=line><span class=cl>gate_demo(gates=&#39;pauli&#39;)
</span></span><span class=line><span class=cl>qc.y(0) # 在第0个量子比特上放上Y门
</span></span><span class=line><span class=cl>qc.z(0) # 在第0个量子比特上放上Z门
</span></span><span class=line><span class=cl>qc.draw()
</span></span></code></pre></td></tr></table></div></div><p>我们可以得到：</p><p><img loading=lazy src=https://pic3.zhimg.com/v2-3ddd3c7e6ea8a801519d024dea957176_1440w.jpg></p><p>我们得到的结果</p><p>类似的，我们接着引入  门和  门：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>from qiskit_textbook.widgets import gate_demo
</span></span><span class=line><span class=cl>gate_demo(gates=&#39;pauli+h+p&#39;)
</span></span></code></pre></td></tr></table></div></div><p>在Qiskit中，我们通常通过两个变量来描述  门：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>qc = QuantumCircuit(1)
</span></span><span class=line><span class=cl>qc.p(pi/4, 0) # 前面一个数字用来表示phi，后面一个数字来表示需要操作的量子比特
</span></span><span class=line><span class=cl>qc.draw()
</span></span></code></pre></td></tr></table></div></div><p>我们可以得到：</p><p><img loading=lazy src=https://pic4.zhimg.com/v2-0cc968ae5eca211d4839ec29abba8477_1440w.jpg></p><p>我们得到的结果</p><p>以上就是一些常用的量子系统的状态和量子门的表达方式，这里的内容肯定不是足够详尽的，如果在实际使用中遇到了不常见的情况，我们可以通过登陆Qiskit或者IBM的官网进行查询。</p><h2 id=2-从传统算法到量子算法>2. 从传统算法到量子算法<a hidden class=anchor aria-hidden=true href=#2-从传统算法到量子算法>#</a></h2><h3 id=21deutsch-jozsa算法>2.1. Deutsch-Jozsa算法<a hidden class=anchor aria-hidden=true href=#21deutsch-jozsa算法>#</a></h3><p>在之前的内容中，我们介绍了D-J算法的使用场景和主要结构，D-J算法为了解决判断输入的函数  为常函数还是平衡函数而诞生。那么如果我们想要在Qiskit中运行，我们应该怎么做呢？在本文的例子中，我们针对以下函数进行算法的撰写，具体算法是怎么写出来的，不是本文的重点内容，这里我们重点关注如何在Qiskit中实现：</p><p><img loading=lazy src=https://pica.zhimg.com/v2-cd503618280235bd9c990b5d011acdfe_1440w.jpg></p><p>第一步我们要初始化所有的量子比特以满足D-J算法的需求：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>dj_circuit = QuantumCircuit(n+1, n)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl># 应用H门
</span></span><span class=line><span class=cl>for qubit in range(n):
</span></span><span class=line><span class=cl>    dj_circuit.h(qubit)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl># 将最底部的量子比特转化成 |-&gt;
</span></span><span class=line><span class=cl>dj_circuit.x(n)
</span></span><span class=line><span class=cl>dj_circuit.h(n)
</span></span><span class=line><span class=cl>dj_circuit.draw()
</span></span></code></pre></td></tr></table></div></div><p>第二步我们要加上预言机里的量子门：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>dj_circuit = QuantumCircuit(n+1, n)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl># 应用H门
</span></span><span class=line><span class=cl>for qubit in range(n):
</span></span><span class=line><span class=cl>    dj_circuit.h(qubit)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl># 将最底部的量子比特转化成 |-&gt;
</span></span><span class=line><span class=cl>dj_circuit.x(n)
</span></span><span class=line><span class=cl>dj_circuit.h(n)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl># 增加预言机里的量子门
</span></span><span class=line><span class=cl>dj_circuit = dj_circuit.compose(balanced_oracle)
</span></span><span class=line><span class=cl>dj_circuit.draw()
</span></span></code></pre></td></tr></table></div></div><p>最后我们要根据算法的结构在n个量子比特上加入  门，并测量所有输入的量子寄存器：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>dj_circuit = QuantumCircuit(n+1, n)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl># 应用H门
</span></span><span class=line><span class=cl>for qubit in range(n):
</span></span><span class=line><span class=cl>    dj_circuit.h(qubit)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl># 将最底部的量子比特转化成 |-&gt;
</span></span><span class=line><span class=cl>dj_circuit.x(n)
</span></span><span class=line><span class=cl>dj_circuit.h(n)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl># 增加预言机里的量子门
</span></span><span class=line><span class=cl>dj_circuit = dj_circuit.compose(balanced_oracle)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl># 重复H门
</span></span><span class=line><span class=cl>for qubit in range(n):
</span></span><span class=line><span class=cl>    dj_circuit.h(qubit)
</span></span><span class=line><span class=cl>dj_circuit.barrier()
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl># 测量
</span></span><span class=line><span class=cl>for i in range(n):
</span></span><span class=line><span class=cl>    dj_circuit.measure(i, i)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl># 表示电路
</span></span><span class=line><span class=cl>dj_circuit.draw()
</span></span></code></pre></td></tr></table></div></div><p>于是我们可以得到：</p><p><img loading=lazy src=https://pic1.zhimg.com/v2-34add6b17ec54854b645be623f376bd8_1440w.jpg></p><p>D-J算法</p><p>如果我们想得到测量的结果，我们可以重复上面学习过的使用量子模拟器的方法：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>aer_sim = Aer.get_backend(&#39;aer_simulator&#39;)
</span></span><span class=line><span class=cl>results = aer_sim.run(dj_circuit).result()
</span></span><span class=line><span class=cl>answer = results.get_counts()
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>plot_histogram(answer)
</span></span></code></pre></td></tr></table></div></div><p>我们可以得到结果：</p><p><img loading=lazy src=https://pic3.zhimg.com/v2-111cfebea501abb57d5a1acac3fc3b2a_1440w.jpg></p><p>我们得到的结果</p><p>根据我们之前学习的内容，如果所有量子比特的测量结果都为0，那么这个函数就可以判断为常函数；如果我们得到任何0之外的结果，那么这个函数就可以判断为平衡函数。从我们得到的结果我们可以很明显看出这个函数为平衡函数。</p><h3 id=22simon算法>2.2. Simon算法<a hidden class=anchor aria-hidden=true href=#22simon算法>#</a></h3><p>在之前的学习中我们了解了Simon算法的使用场景和基本结构，那么我们怎么在Qiskit中实现Simon算法呢？我们这里可以直接通过simon_oracle创造一个Simon算法的预言机，在这里的例子里，我们假设  。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl># 引入Qiskit的各类工具
</span></span><span class=line><span class=cl>from qiskit import IBMQ, Aer
</span></span><span class=line><span class=cl>from qiskit.providers.ibmq import least_busy
</span></span><span class=line><span class=cl>from qiskit import QuantumCircuit, transpile
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>from qiskit.visualization import plot_histogram
</span></span><span class=line><span class=cl>from qiskit_textbook.tools import simon_oracle
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>b = &#39;110&#39;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>n = len(b)
</span></span><span class=line><span class=cl>simon_circuit = QuantumCircuit(n*2, n)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl># 根据Simon算法的结构应用H门
</span></span><span class=line><span class=cl>simon_circuit.h(range(n))    
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl># 在这里增加barrier以区分不同区域
</span></span><span class=line><span class=cl>simon_circuit.barrier()
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl># 这里我们直接通过simon_oracle创造一个simon算法的预言机
</span></span><span class=line><span class=cl>simon_circuit = simon_circuit.compose(simon_oracle(b))
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl># 在这里增加barrier以区分不同的区域
</span></span><span class=line><span class=cl>simon_circuit.barrier()
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl># 根据Simon算法的结构应用H门
</span></span><span class=line><span class=cl>simon_circuit.h(range(n))
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl># 测量量子比特
</span></span><span class=line><span class=cl>simon_circuit.measure(range(n), range(n))
</span></span><span class=line><span class=cl>simon_circuit.draw()
</span></span></code></pre></td></tr></table></div></div><p>我们在这里得到的结果为：</p><p><img loading=lazy src=https://pica.zhimg.com/v2-ee6fe636a003cbc314faf4aaa2cf6fa0_1440w.jpg></p><p>我们在这里得到的结果</p><p>类似的，我们可以通过使用量子模拟器来得到测量的结果：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>aer_sim = Aer.get_backend(&#39;aer_simulator&#39;)
</span></span><span class=line><span class=cl>results = aer_sim.run(simon_circuit).result()
</span></span><span class=line><span class=cl>counts = results.get_counts()
</span></span><span class=line><span class=cl>plot_histogram(counts)
</span></span></code></pre></td></tr></table></div></div><p>于是我们可以得到如下的结果，之后我们再应用传统算法就可以得到最后的结果：</p><p><img loading=lazy src=https://pica.zhimg.com/v2-1ca31da630600c7816a860db5f9c43f6_1440w.jpg></p><p>在之前的内容中，我们同样引入了Shor算法、Grover算法和QAOA算法，由于这几个算法涉及<strong>量子傅里叶变换 (Quantum Fourier Transform)和QPE算法 (Quantum Phase Estimation)</strong>，我之后会针对这个内容做一个专题进行解释和总结。</p><h2 id=3-量子计算在密码学中的应用>3. 量子计算在密码学中的应用<a hidden class=anchor aria-hidden=true href=#3-量子计算在密码学中的应用>#</a></h2><h3 id=31量子密钥分发qkd>3.1. 量子密钥分发 (QKD)<a hidden class=anchor aria-hidden=true href=#31量子密钥分发qkd>#</a></h3><p>我们在之前的内容中介绍了量子密钥分发的原理，即如果Alice希望发送给Bob一个量子比特，但窃听者试图在Bob之前测量这个量子比特，那么窃听者的测量有可能改变量子比特的状态，而Bob将接收不到Alice发送的量子比特的状态。假设Alice希望用x基来表示  ，并将其发给Bob，如果Bob同样用x基来进行解密，那么他一定会得到  ，在Qiskit我们这样表示：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>from qiskit import QuantumCircuit, Aer, transpile
</span></span><span class=line><span class=cl>from qiskit.visualization import plot_histogram, plot_bloch_multivector
</span></span><span class=line><span class=cl>from numpy.random import randint
</span></span><span class=line><span class=cl>import numpy as np
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>qc = QuantumCircuit(1,1)
</span></span><span class=line><span class=cl># Alice 将量子比特转换成|+&gt;来发送
</span></span><span class=line><span class=cl>qc.h(0)
</span></span><span class=line><span class=cl>qc.barrier()
</span></span><span class=line><span class=cl># Alice 现在把这个量子比特发送给Bob
</span></span><span class=line><span class=cl># Bob 使用相同的基来进行测量
</span></span><span class=line><span class=cl>qc.h(0)
</span></span><span class=line><span class=cl>qc.measure(0,0)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl># 画出并模拟电路
</span></span><span class=line><span class=cl>display(qc.draw())
</span></span><span class=line><span class=cl>aer_sim = Aer.get_backend(&#39;aer_simulator&#39;)
</span></span><span class=line><span class=cl>job = aer_sim.run(qc)
</span></span><span class=line><span class=cl>plot_histogram(job.result().get_counts())
</span></span></code></pre></td></tr></table></div></div><p>我们可以得到：</p><p><img loading=lazy src=https://picx.zhimg.com/v2-e18dff45e2014106c12b8d8b9bffccc5_1440w.jpg></p><p>我们得到的结果</p><p>通过之前的学习我们知道，如果窃听者在Bob之前尝试通过z基测量，那么Bob就不会一定得到  。在Qiskit中我们这样表示：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>qc = QuantumCircuit(1,1)
</span></span><span class=line><span class=cl># Alice 将量子比特转换成|+&gt;来发送
</span></span><span class=line><span class=cl>qc.h(0)
</span></span><span class=line><span class=cl># Alice 现在把这个量子比特发送给Bob
</span></span><span class=line><span class=cl># 但是窃听者尝试阅读这个消息
</span></span><span class=line><span class=cl>qc.measure(0, 0)
</span></span><span class=line><span class=cl>qc.barrier()
</span></span><span class=line><span class=cl># 窃听者在解密后将结果传达给Bob
</span></span><span class=line><span class=cl># Bob用x基来进行解密
</span></span><span class=line><span class=cl>qc.h(0)
</span></span><span class=line><span class=cl>qc.measure(0,0)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl># 画出并模拟电路
</span></span><span class=line><span class=cl>display(qc.draw())
</span></span><span class=line><span class=cl>aer_sim = Aer.get_backend(&#39;aer_simulator&#39;)
</span></span><span class=line><span class=cl>job = aer_sim.run(qc)
</span></span><span class=line><span class=cl>plot_histogram(job.result().get_counts())
</span></span></code></pre></td></tr></table></div></div><p>我们可以得到如下的结果：</p><p><img loading=lazy src=https://pic1.zhimg.com/v2-8f04df93fa36e39cbb21644e8b444f2e_1440w.jpg></p><p>我们得到的结果</p><p>从结果中我们可以观察到，Bob测量出  的概率仅剩50%左右。</p><h2 id=4-量子机器学习>4. 量子机器学习<a hidden class=anchor aria-hidden=true href=#4-量子机器学习>#</a></h2><p>由于篇幅限制，之后我会针对量子机器学习的内容做一个专题进行解释和总结。</p><blockquote><p>声明：本文的主要内容为针对Qiskit中提供的教程进行的总结</p></blockquote></div><footer class=post-footer><ul class=post-tags><li><a href=https://rosefinch-midsummer.github.io/zh/tags/%E9%87%8F%E5%AD%90%E8%AE%A1%E7%AE%97/>量子计算</a></li><li><a href=https://rosefinch-midsummer.github.io/zh/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/>图像处理</a></li></ul><nav class=paginav><a class=next href=https://rosefinch-midsummer.github.io/zh/posts/book/%E5%8D%A1%E7%89%87%E7%AC%94%E8%AE%B0%E5%86%99%E4%BD%9C%E6%B3%95/><span class=title>下一頁 »</span><br><span>《卡片笔记写作法》</span></a></nav></footer><div><div class=pagination__title><span class=pagination__title-h style=font-size:20px>评论</span><br></div><div id=tcomment></div><script src=https://utteranc.es/client.js repo=Rosefinch-Midsummer/comments_of_blog issue-term=title theme=github-light crossorigin=anonymous async></script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.body.className.includes("dark")?"github-light":"photon-dark",t={type:"set-theme",theme:e},n=document.querySelector(".utterances-frame");n.contentWindow.postMessage(t,"https://utteranc.es")})</script></div></article></main><footer class=footer><span>&copy; 2026 <a href=https://rosefinch-midsummer.github.io/zh/>天漢帝國復興錄</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span><div class=busuanzi-footer><span id=busuanzi_container_site_pv>本站总访问量<span id=busuanzi_value_site_pv></span>次
</span><span id=busuanzi_container_site_uv>本站访客数<span id=busuanzi_value_site_uv></span>人次</span></div></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="複製";function s(){t.innerHTML="已複製！",setTimeout(()=>{t.innerHTML="複製"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>