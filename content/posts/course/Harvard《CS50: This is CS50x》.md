---
title: "Harvardã€ŠCS50: This is CS50xã€‹"
date: 2025-12-06T19:34:25+08:00
lastmod: 2025-12-06T22:54:22+08:00
categories:
- åœ¨çº¿è¯¾ç¨‹
- è®¡ç®—æœº
tags:
- Harvard
- CS50
# description->éœ€è¦è‡ªå·±ç¼–å†™çš„æ–‡ç« æè¿°ï¼Œæ˜¯æœç´¢å¼•æ“å‘ˆç°åœ¨æœç´¢ç»“æœé“¾æ¥ä¸‹æ–¹çš„ç½‘é¡µç®€ä»‹ï¼Œå»ºè®®è®¾ç½®
description: ""
weight: # è¾“å…¥1å¯ä»¥é¡¶ç½®æ–‡ç« ï¼Œç”¨æ¥ç»™æ–‡ç« å±•ç¤ºæ’åºï¼Œä¸å¡«å°±é»˜è®¤æŒ‰æ—¶é—´æ’åº
slug: ""
draft: false # æ˜¯å¦ä¸ºè‰ç¨¿
comments: true
showToc: true # æ˜¾ç¤ºç›®å½•
TocOpen: true # è‡ªåŠ¨å±•å¼€ç›®å½•
hidemeta: false # æ˜¯å¦éšè—æ–‡ç« çš„å…ƒä¿¡æ¯ï¼Œå¦‚å‘å¸ƒæ—¥æœŸã€ä½œè€…ç­‰
disableShare: true # åº•éƒ¨ä¸æ˜¾ç¤ºåˆ†äº«æ 
---


# è¯¾ç¨‹ç®€ä»‹

- æ‰€å±å¤§å­¦ï¼šHarvard
- å…ˆä¿®è¦æ±‚ï¼šæ— 
- ç¼–ç¨‹è¯­è¨€ï¼šC, Python, SQL, HTML, CSS, JavaScript
- è¯¾ç¨‹éš¾åº¦ï¼šğŸŒŸğŸŒŸ
- é¢„è®¡å­¦æ—¶ï¼š20 å°æ—¶

è¿ç»­å¤šå¹´è¢«å“ˆä½›å¤§å­¦å­¦ç”Ÿè¯„ä¸ºæœ€å—æ¬¢è¿çš„å…¬é€‰è¯¾ç¨‹ã€‚Malan æ•™æˆä¸Šè¯¾éå¸¸æœ‰æ¿€æƒ…ï¼Œæ’•é»„é¡µè®²äºŒåˆ†æ³•çš„åœºé¢è®©äººè®°å¿†çŠ¹æ–°ï¼ˆç¬‘ï¼‰ã€‚ä½†å› ä¸ºå®ƒçš„å…¥é—¨ä»¥åŠå…¨æ ¡å…¬é€‰çš„å±æ€§ï¼Œè¯¾ç¨‹å†…å®¹éš¾åº¦æ¯”è¾ƒæ¸©å’Œï¼Œä½†æ˜¯è¯¾ç¨‹ä½œä¸šè´¨é‡éå¸¸é«˜è€Œä¸”å…¨éƒ¨å…è´¹å¼€æºï¼Œéå¸¸é€‚åˆå°ç™½å…¥é—¨ï¼Œæˆ–è€…å¤§ä½¬ä¼‘é—²ã€‚

# è¯¾ç¨‹èµ„æº

- è¯¾ç¨‹ç½‘ç«™ï¼š[2025](https://cs50.harvard.edu/x/2025/),Â [2024](https://cs50.harvard.edu/x/2024/),Â [2023](https://cs50.harvard.edu/x/2023/),Â [2022](https://cs50.harvard.edu/x/2022/)
- è¯¾ç¨‹è§†é¢‘ï¼šåŸç‰ˆå‚è€ƒè¯¾ç¨‹ç½‘ç«™ï¼Œä¹Ÿå¯ä»¥åœ¨ B ç«™æ‰¾åˆ°[ä¸­æ–‡å­—å¹•ç‰ˆ](https://www.bilibili.com/video/BV1HW4y1A7Yi/?spm_id_from=333.999.0.0&vd_source=a4d76d1247665a7e7bec15d15fd12349)ã€‚
- è¯¾ç¨‹æ•™æï¼šæ— 
- è¯¾ç¨‹ä½œä¸šï¼šå‚è€ƒè¯¾ç¨‹ç½‘ç«™ã€‚

# èµ„æºæ±‡æ€»

@mancuoj åœ¨å­¦ä¹ è¿™é—¨è¯¾ä¸­ç”¨åˆ°çš„æ‰€æœ‰èµ„æºå’Œä½œä¸šå®ç°éƒ½æ±‡æ€»åœ¨Â [mancuoj/CS50x - GitHub](https://github.com/mancuoj/CS50x)Â ä¸­ã€‚

@figuretu å°†æœ‰ä»·å€¼çš„æé—®è®¨è®ºä»¥åŠç›¸å…³å­¦ä¹ èµ„æºæ•´ç†åœ¨å…±äº«æ–‡æ¡£Â [CS50 - èµ„æºæ€»ç›®å½•](https://uufyjevghz.feishu.cn/docx/DP78d2U5TosTOTx9QCbcjp8GnBh)Â ä¸­ã€‚


# Notes

## [Câ€”â€”Command-Line Arguments](https://cs50.harvard.edu/x/notes/2/#command-line-arguments)

- `Command-line arguments`Â are those arguments that are passed to your program at the command line. For example, all those statements you typed afterÂ `clang`Â are considered command line arguments. You can use these arguments in your own programs!
- In your terminal window, typeÂ `code greet.c`Â and write code as follows:
    
    ```
    // Uses get_string
    
    #include <cs50.h>
    #include <stdio.h>
    
    int main(void)
    {
        string answer = get_string("What's your name? ");
        printf("hello, %s\n", answer);
    }
    ```
    
    Notice that this saysÂ `hello`Â to the user.
    
- Still, would it not be nice to be able to take arguments before the program even runs? Modify your code as follows:
    
    ```
    // Prints a command-line argument
    
    #include <cs50.h>
    #include <stdio.h>
    
    int main(int argc, string argv[])
    {
        if (argc == 2)
        {
            printf("hello, %s\n", argv[1]);
        }
        else
        {
            printf("hello, world\n");
        }
    }
    ```
    
    Notice that this program knows bothÂ `argc`, the number of command line arguments, andÂ `argv`, which is an array of the characters passed as arguments at the command line.
    
- Therefore, using the syntax of this program, executingÂ `./greet David`Â would result in the program sayingÂ `hello, David`.
- You can print each of the command-line arguments with the following:
    
    ```
    // Prints command-line arguments
    
    #include <cs50.h>
    #include <stdio.h>
    
    int main(int argc, string argv[])
    {
        for (int i = 0; i < argc; i++)
        {
            printf("%s\n", argv[i]);
        }
    }
    ```
    

## [Câ€”â€”Exit Status](https://cs50.harvard.edu/x/notes/2/#exit-status)

- When a program ends, a special exit code is provided to the computer.
- When a program exits without error, a status code ofÂ `0`Â is provided to the computer. Often, when an error occurs that results in the program ending, a status ofÂ `1`Â is provided by the computer.
- You could write a program as follows that illustrates this by typingÂ `code status.c`Â and writing code as follows:
    
    ```
    // Returns explicit value from main
    
    #include <cs50.h>
    #include <stdio.h>
    
    int main(int argc, string argv[])
    {
        if (argc != 2)
        {
            printf("Missing command-line argument\n");
            return 1;
        }
        printf("hello, %s\n", argv[1]);
        return 0;
    }
    ```
    
    Notice that if you fail to provideÂ `./status David`, you will get an exit status ofÂ `1`. However, if you do provideÂ `./status David`, you will get an exit status ofÂ `0`.
    
- You can typeÂ `echo $?`Â in the terminal to see the exit status of the last run command.
- You can imagine how you might use portions of the above program to check if a user provided the correct number of command-line arguments.



## [Copying and malloc](https://cs50.harvard.edu/x/notes/4/#copying-and-malloc)

- A common need in programming is to copy one string to another.
- In your terminal window, typeÂ `code copy.c`Â and write code as follows:
    
    ```
    // Capitalizes a string
    
    #include <cs50.h>
    #include <ctype.h>
    #include <stdio.h>
    #include <string.h>
    
    int main(void)
    {
        // Get a string
        string s = get_string("s: ");
    
        // Copy string's address
        string t = s;
    
        // Capitalize first letter in string
        t[0] = toupper(t[0]);
    
        // Print string twice
        printf("s: %s\n", s);
        printf("t: %s\n", t);
    }
    ```
    
    Notice thatÂ `string t = s`Â copies the address ofÂ `s`Â toÂ `t`. This does not accomplish what we are desiring. The string is not copied â€“ only the address is. Further, notice the inclusion ofÂ `ctype.h`.
    
- You can visualize the above code as follows:
    
    ![two pointers pointing at the same memory location with a string](https://cs50.harvard.edu/x/notes/4/cs50Week4Slide124.png "two strings")
    
    Notice thatÂ `s`Â andÂ `t`Â are still pointing at the same blocks of memory. This is not an authentic copy of a string. Instead, these are two pointers pointing at the same string.
    
- Before we address this challenge, itâ€™s important to ensure that we donâ€™t experience aÂ _segmentation fault_Â through our code, where we attempt to copyÂ `string s`Â toÂ `string t`, whereÂ `string t`Â does not exist. We can employ theÂ `strlen`Â function as follows to assist with that:
    
    ```
    // Capitalizes a string, checking length first
    
    #include <cs50.h>
    #include <ctype.h>
    #include <stdio.h>
    #include <string.h>
    
    int main(void)
    {
        // Get a string
        string s = get_string("s: ");
    
        // Copy string's address
        string t = s;
    
        // Capitalize first letter in string
        if (strlen(t) > 0)
        {
            t[0] = toupper(t[0]);
        }
    
        // Print string twice
        printf("s: %s\n", s);
        printf("t: %s\n", t);
    }
    ```
    
    Notice thatÂ `strlen`Â is used to make sureÂ `string t`Â exists. If it does not, nothing will be copied.
    
- To be able to make an authentic copy of the string, we will need to introduce two new building blocks. First,Â `malloc`Â allows you, the programmer, to allocate a block of a specific size of memory. Second,Â `free`Â allows you to tell the compiler toÂ _free up_Â that block of memory you previously allocated.
    
- We can modify our code to create an authentic copy of our string as follows:
    
    ```
    // Capitalizes a copy of a string
    
    #include <cs50.h>
    #include <ctype.h>
    #include <stdio.h>
    #include <stdlib.h>
    #include <string.h>
    
    int main(void)
    {
        // Get a string
        char *s = get_string("s: ");
    
        // Allocate memory for another string
        char *t = malloc(strlen(s) + 1);
    
        // Copy string into memory, including '\0'
        for (int i = 0; i <= strlen(s); i++)
        {
            t[i] = s[i];
        }
    
        // Capitalize copy
        t[0] = toupper(t[0]);
    
        // Print strings
        printf("s: %s\n", s);
        printf("t: %s\n", t);
    }
    ```
    
    Notice thatÂ `malloc(strlen(s) + 1)`Â creates a block of memory that is the length of the stringÂ `s`Â plus one. This allows for the inclusion of theÂ _null_Â `\0`Â character in our final copied string. Then, theÂ `for`Â loop walks through the stringÂ `s`Â and assigns each value to that same location on the stringÂ `t`.
    
- It turns out that our code is inefficient. Modify your code as follows:
    
    ```
    // Capitalizes a copy of a string, defining n in loop too
    
    #include <cs50.h>
    #include <ctype.h>
    #include <stdio.h>
    #include <stdlib.h>
    #include <string.h>
    
    int main(void)
    {
        // Get a string
        char *s = get_string("s: ");
    
        // Allocate memory for another string
        char *t = malloc(strlen(s) + 1);
    
        // Copy string into memory, including '\0'
        for (int i = 0, n = strlen(s); i <= n; i++)
        {
            t[i] = s[i];
        }
    
        // Capitalize copy
        t[0] = toupper(t[0]);
    
        // Print strings
        printf("s: %s\n", s);
        printf("t: %s\n", t);
    }
    ```
    
    Notice thatÂ `n = strlen(s)`Â is defined now in the left-hand side of theÂ `for loop`. Itâ€™s best not to call unneeded functions in the middle condition of theÂ `for`Â loop, as it will run over and over again. When movingÂ `n = strlen(s)`Â to the left-hand side, the functionÂ `strlen`Â only runs once.
    
- TheÂ `C`Â Language has a built-in function to copy strings calledÂ `strcpy`. It can be implemented as follows:
    
    ```
    // Capitalizes a copy of a string using strcpy
    
    #include <cs50.h>
    #include <ctype.h>
    #include <stdio.h>
    #include <stdlib.h>
    #include <string.h>
    
    int main(void)
    {
        // Get a string
        char *s = get_string("s: ");
    
        // Allocate memory for another string
        char *t = malloc(strlen(s) + 1);
    
        // Copy string into memory
        strcpy(t, s);
    
        // Capitalize copy
        t[0] = toupper(t[0]);
    
        // Print strings
        printf("s: %s\n", s);
        printf("t: %s\n", t);
    }
    ```
    
    Notice thatÂ `strcpy`Â does the same work that ourÂ `for`Â loop previously did.
    
- BothÂ `get_string`Â andÂ `malloc`Â returnÂ `NULL`, a special value in memory, in the event that something goes wrong. You can write code that can check for thisÂ `NULL`Â condition as follows:
    
    ```
    // Capitalizes a copy of a string without memory errors
    
    #include <cs50.h>
    #include <ctype.h>
    #include <stdio.h>
    #include <stdlib.h>
    #include <string.h>
    
    int main(void)
    {
        // Get a string
        char *s = get_string("s: ");
        if (s == NULL)
        {
            return 1;
        }
    
        // Allocate memory for another string
        char *t = malloc(strlen(s) + 1);
        if (t == NULL)
        {
            return 1;
        }
    
        // Copy string into memory
        strcpy(t, s);
    
        // Capitalize copy
        if (strlen(t) > 0)
        {
            t[0] = toupper(t[0]);
        }
    
        // Print strings
        printf("s: %s\n", s);
        printf("t: %s\n", t);
    
        // Free memory
        free(t);
        return 0;
    }
    ```
    
    Notice that if the string obtained is of lengthÂ `0`Â or malloc fails,Â `NULL`Â is returned. Further, notice thatÂ `free`Â lets the computer know you are done with this block of memory you created viaÂ `malloc`.
    

## [Valgrind](https://cs50.harvard.edu/x/notes/4/#valgrind)

- _Valgrind_Â is a tool that can check to see if there are memory-related issues with your programs wherein you utilizedÂ `malloc`. Specifically, it checks to see if youÂ `free`Â all the memory you allocated.
- Consider the following code forÂ `memory.c`:
    
    ```
    // Demonstrates memory errors via valgrind
    
    #include <stdio.h>
    #include <stdlib.h>
    
    int main(void)
    {
        int *x = malloc(3 * sizeof(int));
        x[1] = 72;
        x[2] = 73;
        x[3] = 33;
    }
    ```
    
    Notice that running this program does not cause any errors. WhileÂ `malloc`Â is used to allocate enough memory for an array, the code fails toÂ `free`Â that allocated memory.
    
- If you typeÂ `make memory`Â followed byÂ `valgrind ./memory`, you will get a report from valgrind that will report where memory has been lost as a result of your program. One error that valgrind reveals is that we attempted to assign the value ofÂ `33`Â at the 4th position of the array, where we only allocated an array of sizeÂ `3`. Another error is that we never freedÂ `x`.
- You can modify your code to free the memory ofÂ `x`Â as follows:
    
    ```
    // Demonstrates memory errors via valgrind
    
    #include <stdio.h>
    #include <stdlib.h>
    
    int main(void)
    {
        int *x = malloc(3 * sizeof(int));
        x[1] = 72;
        x[2] = 73;
        x[3] = 33;
        free(x);
    }
    ```
    
    Notice that running valgrind again now results in no memory leaks.
    

## [Garbage Values](https://cs50.harvard.edu/x/notes/4/#garbage-values)

- When you ask the compiler for a block of memory, there is no guarantee that this memory will be empty.
- Itâ€™s very possible that the memory you allocated was previously utilized by the computer. Accordingly, you may seeÂ _junk_Â orÂ _garbage values_. This is a result of you getting a block of memory but not initializing it. For example, consider the following code forÂ `garbage.c`:
    
    ```
    #include <stdio.h>
    #include <stdlib.h>
    
    int main(void)
    {
        int scores[1024];
        for (int i = 0; i < 1024; i++)
        {
            printf("%i\n", scores[i]);
        }
    }
    ```
    
    Notice that running this code will allocateÂ `1024`Â locations in memory for your array, but theÂ `for`Â loop will likely show that not all values therein areÂ `0`. Itâ€™s always best practice to be aware of the potential for garbage values when you do not initialize blocks of memory to some other value like zero or otherwise.




## [Tries](https://cs50.harvard.edu/x/notes/5/#tries)

- _Tries_Â are another form of data structure. Tries are trees of arrays.
- _Tries_Â are always searchable in constant time.
- One downside toÂ _Tries_Â is that they tend to take up a large amount of memory. Notice that we needÂ 26Â Ã—4Â =104Â `node`s just to storeÂ _Toad_!
- _Toad_Â would be stored as follows:
    
    ![toad being spelled with one letter at a time where one letter is associated with one list T from one list O from another and so on](https://cs50.harvard.edu/x/notes/5/cs50Week5Slide207.png "tries")
    
- _Tom_Â would then be stored as follows:
    
    ![toad being spelled with one letter at a time where one letter is associated with one list T from one list O from another and so on and tom being spelled similarly where toad and tom share a two common letters T and O](https://cs50.harvard.edu/x/notes/5/cs50Week5Slide209.png "tries")
    
- This structure offers a search time ofÂ ğ‘‚â¡(1).
- The downside of this structure is how many resources are required to use it.


## [Pythonâ€”â€”Command-Line Arguments](https://cs50.harvard.edu/x/notes/6/#command-line-arguments)

- As with C, you can also utilize command-line arguments. Consider the following code:
    
    ```
    # Prints a command-line argument
    
    from sys import argv
    
    if len(argv) == 2:
        print(f"hello, {argv[1]}")
    else:
        print("hello, world")
    ```
    
    Notice thatÂ `argv[1]`Â is printed using aÂ _formatted string_, noted by theÂ `f`Â present in theÂ `print`Â statement.
    
- You can learn more about theÂ `sys`Â library in theÂ [Python documentation](https://docs.python.org/3/library/sys.html)
    

## [Pythonâ€”â€”Exit Status](https://cs50.harvard.edu/x/notes/6/#exit-status)

- TheÂ `sys`Â library also has built-in methods. We can useÂ `sys.exit(i)`Â to exit the program with a specific exit code:
    
    ```
    # Exits with explicit value, importing sys
    
    import sys
    
    if len(sys.argv) != 2:
        print("Missing command-line argument")
        sys.exit(1)
    
    print(f"hello, {sys.argv[1]}")
    sys.exit(0)
    ```
    
    Notice that dot-notation is used to utilize the built-in functions ofÂ `sys`.


## [Relational Databases](https://cs50.harvard.edu/x/notes/7/#relational-databases)

- Google, X, and Meta all use relational databases to store their information at scale.
- Relational databases store data in rows and columns in structures calledÂ _tables_.
- SQL allows for four types of commands:
    
    ```
      Create
      Read
      Update
      Delete
    ```
    
- These four operations are affectionately calledÂ _CRUD_.
- We can create a database with the SQL syntaxÂ `CREATE TABLE table (column type, ...);`. But where do you run this command?
- `sqlite3`Â is a type of SQL database that has the core features required for this course.
- We can create a SQL database at the terminal by typingÂ `sqlite3 favorites.db`. Upon being prompted, we will agree that we want to createÂ `favorites.db`Â by pressingÂ `y`.
- You will notice a different prompt as we are now using a program calledÂ `sqlite`.
- We can putÂ `sqlite`Â intoÂ `csv`Â mode by typingÂ `.mode csv`. Then, we can import our data from ourÂ `csv`Â file by typingÂ `.import favorites.csv favorites`. It seems that nothing has happened!
- We can typeÂ `.schema`Â to see the structure of the database.
- You can read items from a table using the syntaxÂ `SELECT columns FROM table`.
- For example, you can typeÂ `SELECT * FROM favorites;`Â which will print every row inÂ `favorites`.
- You can get a subset of the data using the commandÂ `SELECT language FROM favorites;`.
- SQL supports many commands to access data, including:
    
    ```SQL
      AVG
      COUNT
      DISTINCT
      LOWER
      MAX
      MIN
      UPPER
    ```
    
- For example, you can typeÂ `SELECT COUNT(*) FROM favorites;`. Further, you can typeÂ `SELECT DISTINCT language FROM favorites;`Â to get a list of the individual languages within the database. You could even typeÂ `SELECT COUNT(DISTINCT language) FROM favorites;`Â to get a count of those.
- SQL offers additional commands we can utilize in our queries:
    
    ```
      WHERE       -- adding a Boolean expression to filter our data
      LIKE        -- filtering responses more loosely
      ORDER BY    -- ordering responses
      LIMIT       -- limiting the number of responses
      GROUP BY    -- grouping responses together
    ```
    
    Notice that we useÂ `--`Â to write a comment in SQL.


## [SQL Injection Attacks](https://cs50.harvard.edu/x/notes/7/#sql-injection-attacks)

- Now, still considering the code above, you might be wondering what theÂ `?`Â question marks do above. One of the problems that can arise in real-world applications of SQL is what is called anÂ _injection attack_. An injection attack is where a malicious actor could input malicious SQL code.
- For example, consider a login screen as follows:
    
    ![harvard key login screen with username and password fields](https://cs50.harvard.edu/x/notes/7/cs50Week7Slide051.png "harvard key login screen")
    
- Without the proper protections in our own code, a bad actor could run malicious code. Consider the following:
    
    ```
    rows = db.execute("SELECT COUNT(*) FROM users WHERE username = ? AND password = ?", username, password)
    ```
    
    Notice that because theÂ `?`Â is in place, validation can be run onÂ `favorite`Â before it is blindly accepted by the query.
    
- You never want to utilize formatted strings in queries as above or blindly trust the userâ€™s input.
- Utilizing the CS50 Library, the library willÂ _sanitize_Â and remove any potentially malicious characters.


## [http-server](https://cs50.harvard.edu/x/notes/9/#http-server)

- Up until this point, all HTML you saw was pre-written and static.
- In the past, when you visited a page, the browser downloaded an HTML page, and you were able to view it. These are consideredÂ _static_Â pages, in that what is programmed in the HTML is exactly what the user sees and downloadsÂ _client-side_Â to their internet browser.
- Dynamic pages refer to the ability of Python and similar languages to create HTML on-the-fly. Accordingly, you can have web pages that are generatedÂ _server-side_Â by code based upon the input or behavior of users.
- You have usedÂ `http-server`Â in the past to serve your web pages. Today, we are going to utilize a new server that can parse out a web address and perform actions based on the URL provided.
- Further, last week, you saw URLs as follows:
    
    ```
    https://www.example.com/folder/file.html
    ```
    
    Notice thatÂ `file.html`Â is an HTML file inside a folder calledÂ `folder`Â atÂ `example.com`.

## [Cookies and Session](https://cs50.harvard.edu/x/notes/9/#cookies-and-session)

- `app.py`Â is considered aÂ _controller_. AÂ _view_Â is considered what the users see. AÂ _model_Â is how data is stored and manipulated. Together, this is referred to asÂ _MVC_Â (model, view, controller).
- While the prior implementation ofÂ `froshims`Â is useful from an administrative standpoint, where a back-office administrator could add and remove individuals from the database, one can imagine how this code is not safe to implement on a public server.
- For one, bad actors could make decisions on behalf of other users by hitting the deregister button â€“ effectively deleting their recorded answer from the server.
- Web services like Google use login credentials to ensure users only have access to the right data.
- We can actually implement this itself usingÂ _cookies_. Cookies are small files that are stored on your computer such that your computer can communicate with the server and effectively say, â€œIâ€™m an authorized user that has already logged in.â€ This authorization through this cookie is called aÂ _session_.
- Cookies may be stored as follows:
    
    ```
    GET / HTTP/2
    Host: accounts.google.com
    Cookie: session=value
    ```
    
    Here, aÂ `session`Â id is stored with a particularÂ `value`Â representing that session.
    
- In the simplest form, we can implement this by creating a folder calledÂ `login`Â and then adding the following files.
- First, create a file calledÂ `requirements.txt`Â that reads as follows:
    
    ```
    Flask
    Flask-Session
    ```
    
    Notice that in addition toÂ `Flask`, we also includeÂ `Flask-Session`, which is required to support login sessions.
    
- Second, in aÂ `templates`Â folder, create a file calledÂ `layout.html`Â that appears as follows:
    
    ```
    <!DOCTYPE html>
    
    <html lang="en">
    
        <head>
            <meta name="viewport" content="initial-scale=1, width=device-width">
            <title>login</title>
        </head>
    
        <body>
            {% block body %}{% endblock %}
        </body>
    
    </html>
    ```
    
    Notice this provides a very simple layout with a title and a body.
    
- Third, create a file in theÂ `templates`Â folder calledÂ `index.html`Â that appears as follows:
    
    ```
    {% extends "layout.html" %}
    
    {% block body %}
    
        {% if name -%}
            You are logged in as {{ name }}. <a href="/logout">Log out</a>.
        {%- else -%}
            You are not logged in. <a href="/login">Log in</a>.
        {%- endif %}
    
    {% endblock %}
    ```
    
    Notice that this file looks to see ifÂ `session["name"]`Â exists (elaborated further inÂ `app.py`Â below). If it does, it will display a welcome message. If not, it will recommend you browse to a page to log in.
    
- Fourth, create a file calledÂ `login.html`Â and add the following code:
    
    ```
    {% extends "layout.html" %}
    
    {% block body %}
    
        <form action="/login" method="post">
            <input autocomplete="off" autofocus name="name" placeholder="Name" type="text">
            <button type="submit">Log In</button>
        </form>
    
    {% endblock %}
    ```
    
    Notice this is the layout of a basic login page.
    
- Finally, create a file calledÂ `app.py`Â and write code as follows:
    
    ```
    from flask import Flask, redirect, render_template, request, session
    from flask_session import Session
    
    # Configure app
    app = Flask(__name__)
    
    # Configure session
    app.config["SESSION_PERMANENT"] = False
    app.config["SESSION_TYPE"] = "filesystem"
    Session(app)
    
    
    @app.route("/")
    def index():
        return render_template("index.html", name=session.get("name"))
    
    
    @app.route("/login", methods=["GET", "POST"])
    def login():
        if request.method == "POST":
            session["name"] = request.form.get("name")
            return redirect("/")
        return render_template("login.html")
    
    
    @app.route("/logout")
    def logout():
        session.clear()
        return redirect("/")
    ```
    
    Notice the modifiedÂ _imports_Â at the top of the file, includingÂ `session`, which will allow you to support sessions. Most importantly, notice howÂ `session["name"]`Â is used in theÂ `login`Â andÂ `logout`Â routes. TheÂ `login`Â route will assign the login name provided and assign it toÂ `session["name"]`. However, in theÂ `logout`Â route, the logging out is implemented by clearing the value ofÂ `session`.
    
- TheÂ `session`Â abstraction allows you to ensure only a specific user has access to specific data and features in our application. It allows you to ensure that no one acts on behalf of another user, for good or bad!
- If you wish, you can downloadÂ [our implementation](https://cdn.cs50.net/2024/fall/lectures/9/src9/login/)Â ofÂ `login`.
- You can read more about sessions in theÂ [Flask documentation](https://flask.palletsprojects.com/en/stable/api/#flask.session).












